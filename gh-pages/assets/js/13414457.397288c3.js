"use strict";(globalThis.webpackChunkphysical_ai_curriculum_book=globalThis.webpackChunkphysical_ai_curriculum_book||[]).push([[710],{6277(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>a});var i=s(4848),t=s(8453);const r={sidebar_position:4},o="Nodes, Topics, Services, and Actions",c={id:"module-1-ros2/week-3-5/nodes-topics",title:"Nodes, Topics, Services, and Actions",description:"Understanding ROS 2 Communication Patterns",source:"@site/docs/module-1-ros2/week-3-5/nodes-topics.md",sourceDirName:"module-1-ros2/week-3-5",slug:"/module-1-ros2/week-3-5/nodes-topics",permalink:"/physical-ai-curriculum-book/docs/module-1-ros2/week-3-5/nodes-topics",draft:!1,unlisted:!1,editUrl:"https://github.com/Anam-Noman/physical-ai-curriculum-book/edit/main/docs/module-1-ros2/week-3-5/nodes-topics.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"curriculumSidebar",previous:{title:"ROS 2 Architecture",permalink:"/physical-ai-curriculum-book/docs/module-1-ros2/week-3-5/architecture"},next:{title:"Python AI Agents to Robot Controllers using rclpy",permalink:"/physical-ai-curriculum-book/docs/module-1-ros2/week-3-5/rclpy-bridge"}},l={},a=[{value:"Understanding ROS 2 Communication Patterns",id:"understanding-ros-2-communication-patterns",level:2},{value:"Nodes: The Basic Computational Unit",id:"nodes-the-basic-computational-unit",level:3},{value:"Node Characteristics",id:"node-characteristics",level:4},{value:"Node Lifecycle",id:"node-lifecycle",level:4},{value:"Topics: Publish-Subscribe Communication",id:"topics-publish-subscribe-communication",level:3},{value:"Topic Characteristics",id:"topic-characteristics",level:4},{value:"Quality of Service (QoS) for Topics",id:"quality-of-service-qos-for-topics",level:4},{value:"Common QoS Settings",id:"common-qos-settings",level:4},{value:"Services: Request-Response Communication",id:"services-request-response-communication",level:3},{value:"Service Characteristics",id:"service-characteristics",level:4},{value:"Defining a Service",id:"defining-a-service",level:4},{value:"Service Implementation",id:"service-implementation",level:4},{value:"Actions: Long-Running Tasks with Feedback",id:"actions-long-running-tasks-with-feedback",level:3},{value:"Action Characteristics",id:"action-characteristics",level:4},{value:"Action Implementation",id:"action-implementation",level:4},{value:"Communication Pattern Selection Guide",id:"communication-pattern-selection-guide",level:2},{value:"When to Use Each Pattern",id:"when-to-use-each-pattern",level:3},{value:"Design Best Practices",id:"design-best-practices",level:3},{value:"Topics",id:"topics",level:4},{value:"Services",id:"services",level:4},{value:"Actions",id:"actions",level:4},{value:"Practical Implementation: Connecting AI Agents to Robot Controllers",id:"practical-implementation-connecting-ai-agents-to-robot-controllers",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"nodes-topics-services-and-actions",children:"Nodes, Topics, Services, and Actions"}),"\n",(0,i.jsx)(n.h2,{id:"understanding-ros-2-communication-patterns",children:"Understanding ROS 2 Communication Patterns"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 provides several communication patterns to enable nodes to exchange information and coordinate robot behavior. Understanding these patterns is crucial for building effective robotic systems that connect AI agents to physical robotic bodies."}),"\n",(0,i.jsx)(n.h3,{id:"nodes-the-basic-computational-unit",children:"Nodes: The Basic Computational Unit"}),"\n",(0,i.jsx)(n.p,{children:"A node is a single executable that uses ROS 2 to communicate with other nodes. Nodes are the fundamental building blocks of ROS 2 applications, each responsible for a specific task or capability."}),"\n",(0,i.jsx)(n.h4,{id:"node-characteristics",children:"Node Characteristics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each node runs in its own process"}),"\n",(0,i.jsx)(n.li,{children:"Nodes can be written in different programming languages (C++, Python, etc.)"}),"\n",(0,i.jsx)(n.li,{children:"Nodes communicate with each other through topics, services, actions, and parameters"}),"\n",(0,i.jsx)(n.li,{children:"Nodes can be launched independently or grouped using launch files"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"node-lifecycle",children:"Node Lifecycle"}),"\n",(0,i.jsx)(n.p,{children:"Nodes typically go through phases:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initialization"}),": Setting up communication interfaces, parameters, and internal state"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Running"}),": Processing data, communicating with other nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Shutdown"}),": Cleaning up resources and terminating gracefully"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example of a complete ROS 2 node\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass TalkerNode(Node):\n    def __init__(self):\n        # Initialize the node with the name 'talker'\n        super().__init__('talker')\n        \n        # Create a publisher on the 'chatter' topic with String message type\n        self.publisher = self.create_publisher(String, 'chatter', 10)\n        \n        # Create a timer to publish messages every 0.5 seconds\n        timer_period = 0.5\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        \n        # Counter for messages\n        self.i = 0\n        \n        self.get_logger().info('Talker node initialized')\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'Hello World: {self.i}'\n        self.publisher.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = TalkerNode()\n    \n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"topics-publish-subscribe-communication",children:"Topics: Publish-Subscribe Communication"}),"\n",(0,i.jsx)(n.p,{children:"Topics enable one-way communication where publishers send messages to topics and subscribers receive messages from them. This pattern is ideal for streaming data like sensor readings or robot state information."}),"\n",(0,i.jsx)(n.h4,{id:"topic-characteristics",children:"Topic Characteristics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Loose Coupling"}),": Publishers and subscribers don't need to know about each other"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Broadcasting"}),": Multiple subscribers can receive the same message"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Asynchronous"}),": Communication happens independently of publisher/subscriber processing speeds"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"quality-of-service-qos-for-topics",children:"Quality of Service (QoS) for Topics"}),"\n",(0,i.jsx)(n.p,{children:"QoS parameters allow you to control how messages are handled:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\n\n# Create a QoS profile for reliable communication with keep-all history\nqos_profile = QoSProfile(\n    reliability=ReliabilityPolicy.RELIABLE,\n    history=HistoryPolicy.KEEP_ALL,\n    depth=10\n)\n\npublisher = self.create_publisher(String, 'topic_name', qos_profile)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"common-qos-settings",children:"Common QoS Settings"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reliability"}),": ",(0,i.jsx)(n.code,{children:"RELIABLE"})," (all messages delivered) or ",(0,i.jsx)(n.code,{children:"BEST_EFFORT"})," (best attempt)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Durability"}),": ",(0,i.jsx)(n.code,{children:"TRANSIENT_LOCAL"})," (keep messages for late joiners) or ",(0,i.jsx)(n.code,{children:"VOLATILE"})," (don't keep messages)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"History"}),": ",(0,i.jsx)(n.code,{children:"KEEP_ALL"})," (unlimited queue) or ",(0,i.jsx)(n.code,{children:"KEEP_LAST"})," (fixed-size queue)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"services-request-response-communication",children:"Services: Request-Response Communication"}),"\n",(0,i.jsx)(n.p,{children:"Services provide synchronous request-response communication. A client sends a request to a service server, which processes the request and returns a response."}),"\n",(0,i.jsx)(n.h4,{id:"service-characteristics",children:"Service Characteristics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Synchronous"}),": The client waits for the response"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"One-to-one"}),": One client communicates with one server at a time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stateless"}),": Each request-response cycle is independent"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"defining-a-service",children:"Defining a Service"}),"\n",(0,i.jsxs)(n.p,{children:["Service definitions use ",(0,i.jsx)(n.code,{children:".srv"})," files with the format ",(0,i.jsx)(n.code,{children:"request fields --- response fields"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-srv",children:"# Example service definition (AddTwoInts.srv)\nint64 a\nint64 b\n---\nint64 sum\n"})}),"\n",(0,i.jsx)(n.h4,{id:"service-implementation",children:"Service Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from example_interfaces.srv import AddTwoInts\n\nclass ServerNode(Node):\n    def __init__(self):\n        super().__init__('server_node')\n        # Create a service server\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Returning: {request.a} + {request.b} = {response.sum}')\n        return response\n\nclass ClientNode(Node):\n    def __init__(self):\n        super().__init__('client_node')\n        # Create a client for the service\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        \n        # Wait for the service to be available\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        \n        self.send_request_async()\n\n    def send_request_async(self):\n        request = AddTwoInts.Request()\n        request.a = 42\n        request.b = 3\n        # Send the request asynchronously\n        self.future = self.cli.call_async(request)\n        self.future.add_done_callback(self.response_callback)\n\n    def response_callback(self, future):\n        result = future.result()\n        self.get_logger().info(f'Result of add_two_ints: {result.sum}')\n"})}),"\n",(0,i.jsx)(n.h3,{id:"actions-long-running-tasks-with-feedback",children:"Actions: Long-Running Tasks with Feedback"}),"\n",(0,i.jsx)(n.p,{children:"Actions are designed for long-running tasks that provide feedback during execution and support cancellation. They're ideal for goals like robot navigation or manipulation."}),"\n",(0,i.jsx)(n.h4,{id:"action-characteristics",children:"Action Characteristics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Long-running"}),": Tasks that take significant time to complete"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feedback"}),": Continuous updates on progress"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Goal/Result"}),": Clear start and end states"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cancelability"}),": Tasks can be stopped before completion"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"action-implementation",children:"Action Implementation"}),"\n",(0,i.jsxs)(n.p,{children:["Action definitions use ",(0,i.jsx)(n.code,{children:".action"})," files with the format ",(0,i.jsx)(n.code,{children:"Goal --- Result --- Feedback"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-action",children:"# Example action definition (Fibonacci.action)\nint32 order\n---\nint32[] sequence\n---\nint32[] sequence\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.executors import MultiThreadedExecutor\nfrom rclpy.node import Node\n\nfrom example_interfaces.action import Fibonacci\n\nclass FibonacciActionServer(Node):\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        \n        # Create an action server\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback,\n            callback_group=ReentrantCallbackGroup())\n\n    def goal_callback(self, goal_request):\n        # Accept or reject a client request to begin an action\n        self.get_logger().info('Received goal request')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        # Accept or reject a client request to cancel an action\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    async def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n        \n        # Create feedback message\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n        \n        # Send initial feedback\n        goal_handle.publish_feedback(feedback_msg)\n        \n        # Simulate the long-running process\n        for i in range(1, goal_handle.request.order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled')\n                return Fibonacci.Result()\n            \n            feedback_msg.sequence.append(\n                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])\n            \n            self.get_logger().info(f'Publishing feedback: {feedback_msg.sequence}')\n            goal_handle.publish_feedback(feedback_msg)\n        \n        # Populate result message\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.sequence\n        \n        goal_handle.succeed()\n        self.get_logger().info(f'Returning result: {result.sequence}')\n        \n        return result\n"})}),"\n",(0,i.jsx)(n.h2,{id:"communication-pattern-selection-guide",children:"Communication Pattern Selection Guide"}),"\n",(0,i.jsx)(n.h3,{id:"when-to-use-each-pattern",children:"When to Use Each Pattern"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Pattern"}),(0,i.jsx)(n.th,{children:"Use Case"}),(0,i.jsx)(n.th,{children:"Example"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Topics"})}),(0,i.jsx)(n.td,{children:"Streaming data, sensor readings"}),(0,i.jsx)(n.td,{children:"Camera images, laser scans, robot pose"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Services"})}),(0,i.jsx)(n.td,{children:"Request-response operations"}),(0,i.jsx)(n.td,{children:"Map saving, sensor calibration, parameter updates"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Actions"})}),(0,i.jsx)(n.td,{children:"Long-running tasks with feedback"}),(0,i.jsx)(n.td,{children:"Navigation, arm movements, object detection"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"design-best-practices",children:"Design Best Practices"}),"\n",(0,i.jsx)(n.h4,{id:"topics",children:"Topics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use topics for data that changes continuously"}),"\n",(0,i.jsx)(n.li,{children:"Be mindful of message frequency and bandwidth"}),"\n",(0,i.jsx)(n.li,{children:"Use appropriate QoS settings based on your application needs"}),"\n",(0,i.jsx)(n.li,{children:"Consider message size and frequency for real-time performance"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"services",children:"Services"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use services for operations with clear input and output"}),"\n",(0,i.jsx)(n.li,{children:"Avoid using services for streaming data"}),"\n",(0,i.jsx)(n.li,{children:"Design services to be stateless when possible"}),"\n",(0,i.jsx)(n.li,{children:"Handle service failures gracefully"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"actions",children:"Actions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use actions for goals that take time to complete"}),"\n",(0,i.jsx)(n.li,{children:"Provide meaningful feedback during execution"}),"\n",(0,i.jsx)(n.li,{children:"Design tasks to be cancelable"}),"\n",(0,i.jsx)(n.li,{children:"Return appropriate results when successful"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"practical-implementation-connecting-ai-agents-to-robot-controllers",children:"Practical Implementation: Connecting AI Agents to Robot Controllers"}),"\n",(0,i.jsx)(n.p,{children:"Let's look at how these communication patterns work together to connect AI agents to robot controllers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# AI Agent Node\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import String\n\nclass AIAgentNode(Node):\n    def __init__(self):\n        super().__init__('ai_agent')\n        \n        # Subscribe to sensor data\n        self.scan_sub = self.create_subscription(\n            LaserScan, 'scan', self.scan_callback, 10)\n        \n        # Publish commands to robot controller\n        self.cmd_pub = self.create_publisher(Twist, 'cmd_vel', 10)\n        \n        # Publish high-level decisions\n        self.decision_pub = self.create_publisher(String, 'decisions', 10)\n        \n        self.obstacle_detected = False\n\n    def scan_callback(self, msg):\n        # Process sensor data\n        min_distance = min(msg.ranges)\n        \n        # Simple AI decision making\n        cmd = Twist()\n        if min_distance < 1.0:  # Obstacle within 1 meter\n            self.obstacle_detected = True\n            cmd.linear.x = 0.0\n            cmd.angular.z = 0.5  # Turn\n            self.decision_pub.publish(String(data=\"Turning due to obstacle\"))\n        else:\n            self.obstacle_detected = False\n            cmd.linear.x = 0.5  # Move forward\n            cmd.angular.z = 0.0\n            self.decision_pub.publish(String(data=\"Moving forward\"))\n        \n        # Send command to robot controller\n        self.cmd_pub.publish(cmd)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"Understanding the different communication patterns in ROS 2 is essential for building effective robotic systems. Nodes provide the basic computational units, while topics, services, and actions define how information flows between them. By choosing the appropriate pattern for your use case, you can create robust and efficient robot software that effectively bridges digital AI models with physical robotic bodies."}),"\n",(0,i.jsx)(n.p,{children:"These communication patterns form the foundation for connecting AI agents to robot controllers, enabling the implementation of complex behaviors that require both high-level intelligence and low-level control."})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>o,x:()=>c});var i=s(6540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);