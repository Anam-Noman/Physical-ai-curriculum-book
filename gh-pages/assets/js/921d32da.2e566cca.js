"use strict";(globalThis.webpackChunkphysical_ai_curriculum_book=globalThis.webpackChunkphysical_ai_curriculum_book||[]).push([[379],{3477(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>_,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var o=t(4848),r=t(8453);const i={sidebar_position:2},s="Bipedal Locomotion and Balance",a={id:"module-3-ai-brain/week-11-12/locomotion-balance",title:"Bipedal Locomotion and Balance",description:"Introduction to Humanoid Locomotion",source:"@site/docs/module-3-ai-brain/week-11-12/locomotion-balance.md",sourceDirName:"module-3-ai-brain/week-11-12",slug:"/module-3-ai-brain/week-11-12/locomotion-balance",permalink:"/physical-ai-curriculum-book/docs/module-3-ai-brain/week-11-12/locomotion-balance",draft:!1,unlisted:!1,editUrl:"https://github.com/Anam-Noman/physical-ai-curriculum-book/edit/main/docs/module-3-ai-brain/week-11-12/locomotion-balance.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"curriculumSidebar",previous:{title:"Humanoid Kinematics and Dynamics",permalink:"/physical-ai-curriculum-book/docs/module-3-ai-brain/week-11-12/humanoid-dynamics"},next:{title:"Manipulation and Grasping",permalink:"/physical-ai-curriculum-book/docs/module-3-ai-brain/week-11-12/manipulation-grasping"}},l={},c=[{value:"Introduction to Humanoid Locomotion",id:"introduction-to-humanoid-locomotion",level:2},{value:"Principles of Bipedal Movement",id:"principles-of-bipedal-movement",level:2},{value:"Biomechanics and Human Walking",id:"biomechanics-and-human-walking",level:3},{value:"Dynamic vs Static Stability",id:"dynamic-vs-static-stability",level:3},{value:"Walking Gait Phases",id:"walking-gait-phases",level:2},{value:"Gait Cycle Analysis",id:"gait-cycle-analysis",level:3},{value:"Single Support Phase",id:"single-support-phase",level:3},{value:"Balance Control Strategies",id:"balance-control-strategies",level:2},{value:"Center of Mass (COM) Control",id:"center-of-mass-com-control",level:3},{value:"ZMP (Zero Moment Point) Based Control",id:"zmp-zero-moment-point-based-control",level:3},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:2},{value:"Preview Control Method",id:"preview-control-method",level:3},{value:"Advanced Locomotion Patterns",id:"advanced-locomotion-patterns",level:2},{value:"Turning and Steering",id:"turning-and-steering",level:3},{value:"Implementation in Simulation and Real Robots",id:"implementation-in-simulation-and-real-robots",level:2},{value:"Simulation Setup",id:"simulation-setup",level:3},{value:"Balance Recovery Strategies",id:"balance-recovery-strategies",level:2},{value:"Disturbance Response",id:"disturbance-response",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Issue 1: Walking Instability",id:"issue-1-walking-instability",level:3},{value:"Issue 2: Foot Slipping",id:"issue-2-foot-slipping",level:3},{value:"Issue 3: Excessive Joint Torques",id:"issue-3-excessive-joint-torques",level:3},{value:"Issue 4: ZMP Outside Support Polygon",id:"issue-4-zmp-outside-support-polygon",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"bipedal-locomotion-and-balance",children:"Bipedal Locomotion and Balance"}),"\n",(0,o.jsx)(n.h2,{id:"introduction-to-humanoid-locomotion",children:"Introduction to Humanoid Locomotion"}),"\n",(0,o.jsx)(n.p,{children:"Humanoid locomotion represents one of the most challenging problems in robotics, requiring the robot to maintain balance while performing complex, dynamic movements. The ability to walk on two legs is fundamental to humanoid robots, enabling them to navigate human-centric environments effectively. Unlike wheeled robots, bipedal robots must continuously negotiate the balance between stability and mobility, managing complex interactions between multiple degrees of freedom and the environment."}),"\n",(0,o.jsx)(n.p,{children:"Successful locomotion in humanoid robots requires sophisticated control algorithms that can handle the inherent instability of bipedal movement while adapting to environmental changes in real-time. This challenge is amplified by the need to maintain balance during gait transitions, handle external disturbances, and manage energy efficiency during sustained locomotion."}),"\n",(0,o.jsx)(n.h2,{id:"principles-of-bipedal-movement",children:"Principles of Bipedal Movement"}),"\n",(0,o.jsx)(n.h3,{id:"biomechanics-and-human-walking",children:"Biomechanics and Human Walking"}),"\n",(0,o.jsx)(n.p,{children:"Human walking involves a complex interplay of:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Double Support Phase"}),": Both feet in contact with ground"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Single Support Phase"}),": One foot in contact, the other swinging"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Heel Strike"}),": Initial contact of leading foot with ground"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Toe Off"}),": Push-off action with trailing foot"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Mid-Swing"}),": Highest point of swinging foot"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The human body treats walking as a controlled falling process, where the center of mass (COM) oscillates laterally and vertically while maintaining forward momentum. This natural dynamic behavior is what robot designers strive to replicate."}),"\n",(0,o.jsx)(n.h3,{id:"dynamic-vs-static-stability",children:"Dynamic vs Static Stability"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Static Stability"}),": Center of pressure remains within the support polygon at all times. Applicable to slow movement or stationary postures."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Pros: Simple to implement, robust to disturbances"}),"\n",(0,o.jsx)(n.li,{children:"Cons: Energy inefficient, unnatural gait, slow movement"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Dynamic Stability"}),": Center of mass is allowed to move outside the support polygon during portions of gait."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Pros: Energy efficient, natural gait, faster movement"}),"\n",(0,o.jsx)(n.li,{children:"Cons: Computationally complex, sensitive to disturbances"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"walking-gait-phases",children:"Walking Gait Phases"}),"\n",(0,o.jsx)(n.h3,{id:"gait-cycle-analysis",children:"Gait Cycle Analysis"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Gait Cycle (2 steps) -> 100%\n\u251c\u2500\u2500 Stance Phase (60%)\n\u2502   \u251c\u2500\u2500 Initial Double Support (8%)\n\u2502   \u251c\u2500\u2500 Single Support (40%)\n\u2502   \u251c\u2500\u2500 Terminal Double Support (8%)\n\u2514\u2500\u2500 Swing Phase (40%)\n    \u251c\u2500\u2500 Early Swing (10%)\n    \u251c\u2500\u2500 Mid Swing (20%)\n    \u251c\u2500\u2500 Late Swing (10%)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"single-support-phase",children:"Single Support Phase"}),"\n",(0,o.jsx)(n.p,{children:"During single support, the stance leg bears the full body weight while the swing leg moves forward. This phase requires precise balance control:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import numpy as np\nimport matplotlib.pyplot as plt\n\nclass SingleSupportController:\n    def __init__(self, robot_params):\n        self.robot_params = robot_params\n        self.com_height = robot_params['com_height']  # Center of mass height\n        self.gravity = 9.81  # m/s^2\n        \n    def calculate_pendulum_motion(self, com_position, com_velocity):\n        \"\"\"\n        Approximate bipedal motion using inverted pendulum model\n        \"\"\"\n        # Inverted pendulum model for walking\n        # COM behaves like an inverted pendulum during single support\n        x, y, z = com_position\n        vx, vy, vz = com_velocity\n        \n        # Calculate angular velocity of COM around contact point\n        # This is simplified - real implementation would consider full dynamics\n        omega_x = vy / self.com_height\n        omega_y = -vx / self.com_height\n        \n        # Calculate acceleration required to maintain pendulum motion\n        ax = -omega_x * vy\n        ay = omega_y * vx\n        az = -self.gravity  # dominated by gravity\n        \n        return np.array([ax, ay, az])\n\n    def balance_control(self, current_state, desired_state):\n        \"\"\"\n        Calculate balance corrections during single support\n        \"\"\"\n        # Current COM position and velocity\n        current_com_pos = current_state['com_position']\n        current_com_vel = current_state['com_velocity']\n        \n        # Desired COM trajectory\n        desired_com_pos = desired_state['com_position']\n        desired_com_vel = desired_state['com_velocity']\n        \n        # Calculate error\n        pos_error = desired_com_pos - current_com_pos\n        vel_error = desired_com_vel - current_com_vel\n        \n        # PID control for balance correction\n        kp = 100.0  # Proportional gain for position\n        kv = 20.0   # Derivative gain for velocity (damping)\n        \n        # Calculate corrective accelerations\n        corrective_acc = kp * pos_error + kv * vel_error\n        \n        # Limit maximum correction to avoid aggressive movements\n        max_correction = 2.0  # m/s^2\n        magnitude = np.linalg.norm(corrective_acc)\n        if magnitude > max_correction:\n            corrective_acc = (corrective_acc / magnitude) * max_correction\n        \n        return corrective_acc\n\nclass WalkingPatternGenerator:\n    def __init__(self, step_length=0.3, step_height=0.1, step_duration=1.0):\n        self.step_length = step_length\n        self.step_height = step_height\n        self.step_duration = step_duration\n        \n    def generate_step_trajectory(self, start_pos, target_pos, support_foot_pos, \n                                 phase_percentage):\n        \"\"\"\n        Generate trajectory for a single step including swing leg motion\n        \"\"\"\n        # Calculate intermediate position based on gait phase\n        t = phase_percentage  # 0.0 to 1.0\n        \n        # Horizontal movement (progressive from start to target)\n        x = start_pos[0] * (1 - t) + target_pos[0] * t\n        y = start_pos[1] * (1 - t) + target_pos[1] * t\n        \n        # Vertical movement (lift and land)\n        # Using sine function for smooth lifting and landing\n        vertical_lift = self.step_height * np.sin(np.pi * t)\n        \n        # Add slight arc to swing trajectory\n        if t < 0.5:\n            # Ascending part of step\n            z = start_pos[2] + vertical_lift\n        else:\n            # Descending part of step\n            z = target_pos[2] + vertical_lift\n        \n        # For lateral stepping, adjust with cosine for smooth side-to-side motion\n        lateral_adjustment = 0.0  # Can be adjusted for side steps\n        if hasattr(self, 'lateral_step') and self.lateral_step:\n            lateral_adjustment = 0.1 * np.sin(np.pi * t)\n        \n        return [x, y + lateral_adjustment, z]\n    \n    def generate_gait_sequence(self, num_steps, forward_speed=0.3, step_height=0.1):\n        \"\"\"\n        Generate complete gait sequence for multiple steps\n        \"\"\"\n        gait_sequence = []\n        \n        # Starting position\n        current_pos = np.array([0.0, 0.0, 0.8])  # Start at COM height\n        \n        for step_idx in range(num_steps):\n            # Determine which foot steps for this step\n            # Alternating pattern: step with left foot on odd steps, right on even\n            stance_foot = 'right' if step_idx % 2 == 0 else 'left'\n            swing_foot = 'left' if stance_foot == 'right' else 'right'\n            \n            # Generate trajectory for this step\n            step_trajectory = self.create_single_step_trajectory(\n                step_idx, stance_foot, forward_speed, step_height\n            )\n            \n            gait_sequence.append({\n                'step_number': step_idx,\n                'stance_foot': stance_foot,\n                'swing_foot': swing_foot,\n                'trajectory': step_trajectory\n            })\n        \n        return gait_sequence\n    \n    def create_single_step_trajectory(self, step_idx, stance_foot, forward_speed, step_height):\n        \"\"\"\n        Create detailed trajectory for a single step\n        \"\"\"\n        # Number of intermediate positions in the step\n        num_intermediate_points = 50\n        trajectory_points = []\n        \n        # Determine swing foot start and target positions\n        if stance_foot == 'right':\n            # Left foot swings forward\n            start_pos = [step_idx * forward_speed, -0.1, 0.0]  # Left foot position\n            target_pos = [(step_idx + 1) * forward_speed, -0.1, 0.0]  # Next left position\n        else:\n            # Right foot swings forward\n            start_pos = [step_idx * forward_speed, 0.1, 0.0]  # Right foot position\n            target_pos = [(step_idx + 1) * forward_speed, 0.1, 0.0]  # Next right position\n        \n        # Generate trajectory points\n        for i in range(num_intermediate_points):\n            t = i / (num_intermediate_points - 1)  # Normalized time (0 to 1)\n            \n            # Calculate position including lifting motion\n            if t < 0.5:\n                # First half: lifting and moving forward\n                pos_x = start_pos[0] + (target_pos[0] - start_pos[0]) * t * 2\n                pos_y = start_pos[1]\n                pos_z = start_pos[2] + step_height * np.sin(np.pi * t * 2)\n            else:\n                # Second half: descending and reaching target\n                pos_x = start_pos[0] + (target_pos[0] - start_pos[0]) * t * 2\n                pos_y = start_pos[1] \n                pos_z = target_pos[2] + step_height * np.sin(np.pi + np.pi * (t - 0.5) * 2)\n            \n            trajectory_points.append([pos_x, pos_y, pos_z])\n        \n        return trajectory_points\n"})}),"\n",(0,o.jsx)(n.h2,{id:"balance-control-strategies",children:"Balance Control Strategies"}),"\n",(0,o.jsx)(n.h3,{id:"center-of-mass-com-control",children:"Center of Mass (COM) Control"}),"\n",(0,o.jsx)(n.p,{children:"The center of mass is the key variable for balance control in humanoid robots. Different strategies have been developed to manage COM position and velocity."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class COMBalancer:\n    def __init__(self, robot_params):\n        self.robot_params = robot_params\n        self.com_position = robot_params['com_initial']\n        self.com_velocity = np.zeros(3)\n        self.com_history = []\n        \n        # PID controller parameters for COM control\n        self.pid_x = {'kp': 80.0, 'ki': 0.1, 'kd': 15.0}\n        self.pid_y = {'kp': 80.0, 'ki': 0.1, 'kd': 15.0}\n        self.pid_z = {'kp': 10.0, 'ki': 0.01, 'kd': 5.0}  # For height control\n        \n    def calculate_zmp_from_com(self, com_pos, com_vel, com_acc):\n        \"\"\"\n        Calculate Zero Moment Point (ZMP) from COM dynamics\n        ZMP_x = x_com - h/g * x_com_ddot\n        ZMP_y = y_com - h/g * y_com_ddot\n        where h = height of COM above ground, g = gravity\n        \"\"\"\n        h = self.robot_params['com_height']  # Height of COM above ground\n        g = 9.81  # Gravity constant\n        \n        zmp_x = com_pos[0] - (h / g) * com_acc[0]\n        zmp_y = com_pos[1] - (h / g) * com_acc[1]\n        \n        return np.array([zmp_x, zmp_y, 0.0])\n    \n    def track_com_trajectory(self, desired_com_traj, current_com_pos, dt):\n        \"\"\"\n        Track a desired COM trajectory using feedback control\n        \"\"\"\n        # Get desired position, velocity and acceleration\n        desired_pos = desired_com_traj['position']\n        desired_vel = desired_com_traj['velocity']\n        desired_acc = desired_com_traj['acceleration']\n        \n        # Calculate errors\n        pos_error = desired_pos - current_com_pos\n        vel_error = desired_vel - self.com_velocity  # Need to track current velocity\n        \n        # Apply PID control\n        control_force = np.zeros(3)\n        control_force[0] = (self.pid_x['kp'] * pos_error[0] + \n                           self.pid_x['kd'] * vel_error[0])\n        control_force[1] = (self.pid_y['kp'] * pos_error[1] + \n                           self.pid_y['kd'] * vel_error[1])\n        control_force[2] = (self.pid_z['kp'] * pos_error[2] + \n                           self.pid_z['kd'] * vel_error[2])\n        \n        # Update COM dynamics\n        total_force = control_force - np.array([0, 0, self.robot_params['total_mass'] * 9.81])\n        com_acc = total_force / self.robot_params['total_mass']\n        \n        # Update velocity and position (Euler integration)\n        self.com_velocity += com_acc * dt\n        self.com_position += self.com_velocity * dt\n        \n        # Record for history\n        self.com_history.append(self.com_position.copy())\n        \n        return control_force, com_acc\n\nclass CapturePointController:\n    def __init__(self, com_height=0.8, gravity=9.81):\n        self.com_height = com_height\n        self.gravity = gravity\n        self.omega = np.sqrt(gravity / com_height)\n        \n    def calculate_capture_point(self, com_pos, com_vel):\n        \"\"\"\n        Calculate capture point where robot should step to stop\n        Capture Point = CoM position + CoM velocity / omega\n        where omega = sqrt(g / h)\n        \"\"\"\n        cp_x = com_pos[0] + com_vel[0] / self.omega\n        cp_y = com_pos[1] + com_vel[1] / self.omega\n        \n        return np.array([cp_x, cp_y, 0.0])\n    \n    def should_step(self, com_pos, com_vel, support_polygon):\n        \"\"\"\n        Determine if a step is needed based on capture point\n        \"\"\"\n        capture_point = self.calculate_capture_point(com_pos, com_vel)\n        \n        # Check if capture point is outside support polygon\n        if not self.point_in_polygon(capture_point[:2], support_polygon):\n            return True, capture_point\n        else:\n            return False, capture_point\n    \n    def point_in_polygon(self, point, polygon):\n        \"\"\"\n        Check if point is inside polygon using ray casting algorithm\n        \"\"\"\n        x, y = point\n        n = len(polygon)\n        inside = False\n        \n        p1x, p1y = polygon[0]\n        for i in range(1, n + 1):\n            p2x, p2y = polygon[i % n]\n            if y > min(p1y, p2y):\n                if y <= max(p1y, p2y):\n                    if x <= max(p1x, p2x):\n                        if p1y != p2y:\n                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                        if p1x == p2x or x <= xinters:\n                            inside = not inside\n            p1x, p1y = p2x, p2y\n        \n        return inside\n"})}),"\n",(0,o.jsx)(n.h3,{id:"zmp-zero-moment-point-based-control",children:"ZMP (Zero Moment Point) Based Control"}),"\n",(0,o.jsx)(n.p,{children:"ZMP-based control is a cornerstone of stable bipedal locomotion:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class ZMPBalancer:\n    def __init__(self, support_polygon=[[0, -0.1], [0.3, -0.1], [0.3, 0.1], [0, 0.1]], \n                 com_height=0.8):\n        self.support_polygon = support_polygon\n        self.com_height = com_height\n        self.gravity = 9.81\n        self.zmp_trajectory = []\n        self.zmp_history = []\n        \n    def calculate_zmp(self, ground_reaction_forces, ground_reaction_moments):\n        """\n        Calculate ZMP from ground reaction forces and moments\n        ZMP = (M_y - F_x * z_0) / F_z, (-M_x - F_y * z_0) / F_z\n        where z_0 is height above ground, M are moments, F are forces\n        """\n        F_x, F_y, F_z = ground_reaction_forces\n        M_x, M_y, M_z = ground_reaction_moments\n        z_0 = 0  # Height of ZMP plane (ground level)\n        \n        if abs(F_z) < 0.01:  # Avoid division by near-zero force\n            return np.array([0.0, 0.0, 0.0])\n        \n        zmp_x = (M_y - F_x * z_0) / F_z\n        zmp_y = (-M_x - F_y * z_0) / F_z\n        \n        return np.array([zmp_x, zmp_y, zmp_0])\n    \n    def track_zmp_trajectory(self, desired_zmp_trajectory, current_com_state):\n        """\n        Track desired ZMP trajectory using COM control\n        """\n        com_pos, com_vel, com_acc = current_com_state\n        \n        # Calculate current ZMP\n        current_zmp = self.calculate_zmp_from_com(com_pos, com_vel, com_acc)\n        \n        # Calculate ZMP error\n        zmp_error = desired_zmp_trajectory - current_zmp\n        \n        # Design control law to track ZMP\n        # For a simplified model: F = m*(g*zmp_error/h + com_ddot_desired)\n        k_p = 100.0  # Proportional gain\n        k_v = 20.0   # Velocity feedback gain\n        \n        # Calculate desired COM acceleration to correct ZMP\n        desired_com_acc = np.zeros(3)\n        desired_com_acc[0] = k_p * zmp_error[0] * self.gravity / self.com_height\n        desired_com_acc[1] = k_p * zmp_error[1] * self.gravity / self.com_height\n        \n        # Also add velocity damping\n        desired_com_acc[0] -= k_v * com_vel[0]\n        desired_com_acc[1] -= k_v * com_vel[1]\n        \n        return desired_com_acc, zmp_error\n    \n    def calculate_zmp_from_com(self, com_pos, com_vel, com_acc):\n        """\n        Calculate ZMP from COM kinematics (inverse of the relationship)\n        """\n        h = self.com_height\n        g = self.gravity\n        \n        zmp_x = com_pos[0] - (h / g) * com_acc[0]\n        zmp_y = com_pos[1] - (h / g) * com_acc[1]\n        \n        return np.array([zmp_x, zmp_y, 0.0])\n    \n    def generate_zmp_trajectory(self, step_positions, step_duration=1.0, dt=0.01):\n        """\n        Generate ZMP trajectory following reference foot positions\n        """\n        num_steps = int(step_duration / dt)\n        zmp_trajectory = []\n        \n        for i in range(len(step_positions) - 1):\n            start_pos = step_positions[i]\n            end_pos = step_positions[i + 1]\n            \n            for j in range(num_steps):\n                t = j / num_steps  # Progress from 0 to 1\n                \n                # Smooth transition between foot positions\n                current_zmp = (1 - t) * start_pos + t * end_pos\n                \n                # Add slight smoothing near foot placements\n                if t < 0.1:  # Early in transition\n                    # Stay near previous foot\n                    current_zmp = start_pos * 0.9 + current_zmp * 0.1\n                elif t > 0.9:  # Late in transition\n                    # Approach next foot position\n                    current_zmp = end_pos * 0.9 + current_zmp * 0.1\n                \n                zmp_trajectory.append(current_zmp)\n        \n        return zmp_trajectory\n'})}),"\n",(0,o.jsx)(n.h2,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,o.jsx)(n.h3,{id:"preview-control-method",children:"Preview Control Method"}),"\n",(0,o.jsx)(n.p,{children:"Preview control uses future reference trajectories to anticipate and compensate for robot dynamics:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class PreviewController:\n    def __init__(self, preview_horizon=20, dt=0.01):\n        self.preview_horizon = preview_horizon\n        self.dt = dt\n        self.com_height = 0.8\n        self.gravity = 9.81\n        \n        # Calculate preview control gain matrix\n        self.K_x, self.K_ref = self.calculate_preview_gains()\n        \n    def calculate_preview_gains(self):\n        \"\"\"\n        Calculate preview control gains using Riccati equation solution\n        This is a simplified implementation\n        \"\"\"\n        # For inverted pendulum model: x_ddot = g/h * x - g/h * zmp\n        # State: x = [com_pos, com_vel], u = zmp_ref\n        # A = [[0, 1], [g/h, 0]], B = [0, -g/h]\n        A = np.array([[0, 1], [self.gravity/self.com_height, 0]])\n        B = np.array([0, -self.gravity/self.com_height])\n        \n        # Cost matrices (Q for state error, R for control effort)\n        Q = np.diag([10.0, 1.0])  # Higher penalty on position error\n        R = np.array([[0.1]])      # Penalty on ZMP deviation\n        \n        # Solve discrete Riccati equation\n        # This requires more complex mathematics in practice\n        # For simplicity, we'll use approximate gains\n        K_x = np.array([3.16, 3.46])  # State feedback gains\n        K_ref = np.array([3.16])      # Feedforward gains\n        \n        return K_x, K_ref\n    \n    def generate_reference_trajectory(self, step_sequence, dt=0.01):\n        \"\"\"\n        Generate reference COM trajectory based on planned foot steps\n        \"\"\"\n        # Calculate total simulation time\n        total_time = len(step_sequence) * 1.0  # 1 second per step\n        num_points = int(total_time / dt)\n        \n        # Initialize reference arrays\n        ref_com_x = np.zeros(num_points)\n        ref_com_y = np.zeros(num_points)\n        ref_zmp_x = np.zeros(num_points)\n        ref_zmp_y = np.zeros(num_points)\n        \n        # Generate smooth transition between foot placements\n        for i, step in enumerate(step_sequence):\n            start_idx = int(i / len(step_sequence) * num_points)\n            end_idx = int((i + 1) / len(step_sequence) * num_points)\n            \n            if i < len(step_sequence) - 1:\n                next_step = step_sequence[i + 1]\n                # Smooth transition between current and next step\n                for j in range(start_idx, min(end_idx, num_points)):\n                    t = (j - start_idx) / (end_idx - start_idx)\n                    # Use cosine interpolation for smooth transitions\n                    ref_com_x[j] = step['com_x'] * (1 + np.cos(np.pi * t)) / 2 + \\\n                                   next_step['com_x'] * (1 - np.cos(np.pi * t)) / 2\n                    ref_com_y[j] = step['com_y'] * (1 + np.cos(np.pi * t)) / 2 + \\\n                                   next_step['com_y'] * (1 - np.cos(np.pi * t)) / 2\n            else:\n                # Last step - hold position\n                for j in range(start_idx, num_points):\n                    ref_com_x[j] = step['com_x']\n                    ref_com_y[j] = step['com_y']\n        \n        return {\n            'ref_com_x': ref_com_x,\n            'ref_com_y': ref_com_y,\n            'ref_zmp_x': ref_zmp_x,\n            'ref_zmp_y': ref_zmp_y\n        }\n    \n    def preview_control_step(self, current_state, reference_sequence, current_time_idx):\n        \"\"\"\n        Calculate control command using preview control\n        \"\"\"\n        # Current state [com_pos, com_vel]\n        x_current = np.array([\n            current_state['com_pos'][0],  # x position\n            current_state['com_vel'][0]   # x velocity\n        ])\n        \n        y_current = np.array([\n            current_state['com_pos'][1],  # y position\n            current_state['com_vel'][1]   # y velocity\n        ])\n        \n        # Extract preview reference (next few reference points)\n        ref_start = current_time_idx\n        ref_end = min(current_time_idx + self.preview_horizon, len(reference_sequence['ref_com_x']))\n        \n        ref_x_preview = reference_sequence['ref_com_x'][ref_start:ref_end]\n        ref_y_preview = reference_sequence['ref_com_y'][ref_start:ref_end]\n        \n        # Calculate control command (simplified)\n        # u = -K_x * x + sum(K_ref * (ref_future - ref_current))\n        command_x = -np.dot(self.K_x, x_current)\n        command_y = -np.dot(self.K_x, y_current)\n        \n        # Add preview compensation\n        for i, (ref_x, ref_y) in enumerate(zip(ref_x_preview, ref_y_preview)):\n            if i == 0:\n                command_x += self.K_ref[0] * (ref_x - x_current[0])\n                command_y += self.K_ref[0] * (ref_y - y_current[0])\n            else:\n                # Diminish effect of future previews\n                weight = np.exp(-0.1 * i)\n                command_x += weight * self.K_ref[0] * (ref_x - x_current[0])\n                command_y += weight * self.K_ref[0] * (ref_y - y_current[0])\n        \n        return np.array([command_x, command_y])\n\nclass WalkingTrajectoryGenerator:\n    def __init__(self, robot_params):\n        self.params = robot_params\n        self.preview_controller = PreviewController()\n        self.zmp_controller = ZMPBalancer()\n        self.com_controller = COMBalancer(robot_params)\n    \n    def generate_walk_trajectory(self, num_steps, step_length=0.3, step_height=0.1, \n                                 step_duration=1.0):\n        \"\"\"\n        Generate complete walking trajectory with balance control\n        \"\"\"\n        print(f\"Generating {num_steps} walking steps...\")\n        \n        # Generate basic step sequence\n        pattern_gen = WalkingPatternGenerator(step_length, step_height, step_duration)\n        step_sequence = pattern_gen.generate_gait_sequence(num_steps)\n        \n        # Generate reference trajectory\n        reference_traj = self.preview_controller.generate_reference_trajectory(\n            [{'com_x': i * step_length, 'com_y': 0.0} for i in range(num_steps)]\n        )\n        \n        # Initialize simulation parameters\n        dt = 0.01  # 100 Hz control loop\n        total_time = num_steps * step_duration\n        num_sim_steps = int(total_time / dt)\n        \n        # Initialize state variables\n        com_pos = np.array([0.0, 0.0, self.params['com_height']])\n        com_vel = np.array([0.0, 0.0, 0.0])\n        com_acc = np.array([0.0, 0.0, 0.0])\n        \n        # Store trajectory for visualization\n        trajectory_log = {\n            'time': [],\n            'com_pos': [],\n            'com_vel': [],\n            'com_acc': [],\n            'zmp_pos': [],\n            'support_polygon': []\n        }\n        \n        # Walking simulation loop\n        for sim_step in range(num_sim_steps):\n            t = sim_step * dt\n            time_idx = int(t / dt)\n            \n            # Determine support polygon based on gait phase\n            support_poly = self.calculate_support_polygon(t, step_sequence)\n            \n            # Current state\n            current_state = {\n                'com_pos': com_pos,\n                'com_vel': com_vel\n            }\n            \n            # Use preview controller for trajectory following\n            control_cmd = self.preview_controller.preview_control_step(\n                current_state, reference_traj, time_idx\n            )\n            \n            # Apply balance corrections\n            current_zmp = self.zmp_controller.calculate_zmp_from_com(\n                com_pos, com_vel, com_acc\n            )\n            \n            # Check if ZMP is within support polygon\n            if not self.point_in_support_polygon(current_zmp[:2], support_poly):\n                # Apply emergency balance correction\n                balance_corr = self.emergency_balance_correction(\n                    com_pos, com_vel, support_poly\n                )\n                control_cmd += balance_corr\n            \n            # Update COM dynamics\n            force = self.calculate_control_force(control_cmd, com_pos, com_vel)\n            acc = force / self.params['total_mass']\n            \n            # Integrate dynamics\n            com_vel += acc * dt\n            com_pos += com_vel * dt\n            \n            # Log trajectory\n            trajectory_log['time'].append(t)\n            trajectory_log['com_pos'].append(com_pos.copy())\n            trajectory_log['com_vel'].append(com_vel.copy())\n            trajectory_log['com_acc'].append(acc.copy())\n            trajectory_log['zmp_pos'].append(current_zmp)\n            trajectory_log['support_polygon'].append(support_poly)\n        \n        print(f\"Walking trajectory generation completed for {num_steps} steps\")\n        return trajectory_log\n    \n    def calculate_support_polygon(self, current_time, step_sequence):\n        \"\"\"\n        Calculate current support polygon based on step timing\n        \"\"\"\n        # Simplified: alternate between single and double support polygons\n        step_duration = 1.0  # Fixed for this example\n        step_num = int(current_time / step_duration)\n        \n        if step_num >= len(step_sequence):\n            step_num = len(step_sequence) - 1\n        \n        # Determine feet positions based on timing within step cycle\n        time_in_step = current_time % step_duration\n        \n        if time_in_step < step_duration * 0.1 or time_in_step > step_duration * 0.9:\n            # Double support phase (both feet down)\n            # Create polygon encompassing both feet\n            left_pos = [step_num * 0.3, -0.1, 0.0]\n            right_pos = [step_num * 0.3, 0.1, 0.0]\n            return self.create_foot_polygon(left_pos, right_pos)\n        else:\n            # Single support phase\n            stance_foot = 'left' if step_num % 2 != 0 else 'right'\n            foot_pos = ([step_num * 0.3, -0.1, 0.0] if stance_foot == 'left' \n                       else [step_num * 0.3, 0.1, 0.0])\n            return self.create_single_foot_polygon(foot_pos)\n    \n    def create_foot_polygon(self, left_pos, right_pos):\n        \"\"\"\n        Create support polygon from foot positions\n        \"\"\"\n        # Simplified rectangular approximation\n        margin = 0.05  # Safety margin\n        \n        min_x = min(left_pos[0], right_pos[0]) - 0.1\n        max_x = max(left_pos[0], right_pos[0]) + 0.1\n        min_y = min(left_pos[1], right_pos[1]) - 0.1\n        max_y = max(left_pos[1], right_pos[1]) + 0.1\n        \n        return [\n            [min_x, min_y],\n            [max_x, min_y], \n            [max_x, max_y],\n            [min_x, max_y]\n        ]\n    \n    def calculate_control_force(self, control_cmd, com_pos, com_vel):\n        \"\"\"\n        Calculate control force from command\n        \"\"\"\n        # Simplified control model\n        kp = 100.0\n        kv = 20.0\n        \n        force_x = kp * (control_cmd[0] - com_pos[0]) - kv * com_vel[0]\n        force_y = kp * (control_cmd[1] - com_pos[1]) - kv * com_vel[1]\n        force_z = self.params['total_mass'] * 9.81  # Compensate for gravity\n        \n        return np.array([force_x, force_y, force_z])\n    \n    def emergency_balance_correction(self, com_pos, com_vel, support_polygon):\n        \"\"\"\n        Apply emergency balance correction if ZMP is outside support polygon\n        \"\"\"\n        # Calculate correction to move ZMP back inside polygon\n        zmp = self.zmp_controller.calculate_zmp_from_com(\n            com_pos, com_vel, np.array([0, 0, 0])  # Assume zero acceleration initially\n        )\n        \n        # Find closest valid ZMP position inside polygon\n        closest_point = self.find_closest_point_in_polygon(zmp[:2], support_polygon)\n        correction = closest_point - zmp[:2]\n        \n        # Amplify correction for urgency\n        return correction * 10.0  # Scale factor for emergency response\n"})}),"\n",(0,o.jsx)(n.h2,{id:"advanced-locomotion-patterns",children:"Advanced Locomotion Patterns"}),"\n",(0,o.jsx)(n.h3,{id:"turning-and-steering",children:"Turning and Steering"}),"\n",(0,o.jsx)(n.p,{children:"Implementing turns and steering for humanoid robots adds complexity to the basic walking pattern:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class TurningController:\n    def __init__(self, robot_params):\n        self.params = robot_params\n        self.base_walking_generator = WalkingPatternGenerator()\n        self.turn_radius = 1.0  # Default turn radius (meters)\n        \n    def generate_turn_trajectory(self, turn_angle, forward_steps=3, \n                                 turn_steps=5, step_length=0.3):\n        \"\"\"\n        Generate trajectory for turning maneuver\n        \"\"\"\n        total_steps = forward_steps + turn_steps\n        trajectory = []\n        \n        # First, perform straight walking\n        for i in range(forward_steps):\n            straight_step = {\n                'step_number': i,\n                'position': [i * step_length, 0, 0],\n                'orientation': 0,  # No turn yet\n                'stance_foot': 'right' if i % 2 == 0 else 'left'\n            }\n            trajectory.append(straight_step)\n        \n        # Then, perform turning steps\n        angle_increment = turn_angle / turn_steps\n        current_angle = 0\n        \n        for i in range(turn_steps):\n            current_angle += angle_increment\n            \n            # Calculate turn position using circular motion\n            arc_length = self.turn_radius * current_angle\n            x_pos = forward_steps * step_length + self.turn_radius * np.sin(current_angle)\n            y_pos = self.turn_radius * (1 - np.cos(current_angle))\n            \n            turn_step = {\n                'step_number': forward_steps + i,\n                'position': [x_pos, y_pos, 0],\n                'orientation': current_angle,\n                'stance_foot': 'right' if (forward_steps + i) % 2 == 0 else 'left'\n            }\n            trajectory.append(turn_step)\n        \n        return trajectory\n    \n    def adjust_com_trajectory_for_turning(self, base_trajectory, turn_params):\n        \"\"\"\n        Adjust COM trajectory to accommodate turning dynamics\n        \"\"\"\n        # Add centripetal acceleration compensation during turns\n        adjusted_trajectory = []\n        \n        for step in base_trajectory:\n            # Calculate lateral forces needed for turning\n            if abs(step['orientation']) > 0.1:  # Significant turn\n                # Add lateral COM displacement for turning stability\n                lat_displacement = 0.05 * np.sign(step['position'][1])  # Lean into turn\n                step['com_adjustment'] = [0, lat_displacement, 0]\n            else:\n                step['com_adjustment'] = [0, 0, 0]\n            \n            adjusted_trajectory.append(step)\n        \n        return adjusted_trajectory\n\n### Terrain Adaptation\n\nAdapting to different terrains requires adjusting gait parameters:\n\nclass TerrainAdaptiveWalker:\n    def __init__(self, robot_params):\n        self.params = robot_params\n        self.terrain_classifications = {\n            'flat': {'max_slope': 0.05, 'height_var': 0.02},\n            'uneven': {'max_slope': 0.15, 'height_var': 0.08},\n            'rough': {'max_slope': 0.30, 'height_var': 0.15},\n            'stairs': {'max_slope': 1.00, 'height_var': 0.20}  # Step height\n        }\n        \n    def classify_terrain(self, terrain_data):\n        \"\"\"\n        Classify terrain based on sensor data\n        \"\"\"\n        # Calculate slope and height variation from terrain data\n        slopes = np.gradient(terrain_data['elevation'])\n        max_slope = np.max(np.abs(slopes))\n        height_var = np.std(terrain_data['elevation'])\n        \n        # Classify terrain type\n        if max_slope <= 0.05 and height_var <= 0.02:\n            return 'flat'\n        elif max_slope <= 0.15 and height_var <= 0.08:\n            return 'uneven'\n        elif max_slope <= 0.30 and height_var <= 0.15:\n            return 'rough'\n        else:\n            return 'complex'  # Stairs or very rough\n    \n    def adapt_gait_for_terrain(self, base_gait, terrain_type):\n        \"\"\"\n        Adapt gait parameters based on terrain type\n        \"\"\"\n        adapted_gait = base_gait.copy()\n        \n        if terrain_type == 'flat':\n            # Standard gait, no modifications\n            pass\n        elif terrain_type == 'uneven':\n            # Increase step height and reduce step length\n            for step in adapted_gait:\n                step['step_height'] *= 1.5  # Higher clearance\n                step['step_length'] *= 0.9  # Shorter steps\n                step['stance_time'] *= 1.1  # Longer stance for stability\n        elif terrain_type == 'rough':\n            # Further increase step height, reduce speed, wider steps\n            for step in adapted_gait:\n                step['step_height'] *= 2.0  # Much higher clearance\n                step['step_length'] *= 0.7  # Shorter steps\n                step['stance_time'] *= 1.3  # Longer stance\n                step['step_width'] *= 1.2  # Wider stance\n        elif terrain_type == 'complex':\n            # Use specialized step-by-step planning\n            for step in adapted_gait:\n                step['step_height'] *= 2.5  # Maximum clearance\n                step['step_length'] *= 0.5  # Very short steps\n                step['cautious_approach'] = True\n        \n        return adapted_gait\n    \n    def reactive_control_for_terrain(self, current_state, terrain_data):\n        \"\"\"\n        Implement reactive control for terrain changes\n        \"\"\"\n        # Detect terrain changes in real-time\n        if terrain_data['slope'] > self.terrain_classifications['uneven']['max_slope']:\n            # Switch to uneven terrain gait\n            return self.adapt_gait_for_terrain(\n                [current_state], \n                'uneven'\n            )[0]\n        elif terrain_data['height_variation'] > self.terrain_classifications['rough']['height_var']:\n            # Switch to rough terrain gait\n            return self.adapt_gait_for_terrain(\n                [current_state], \n                'rough'\n            )[0]\n        else:\n            # Maintain current gait\n            return current_state\n"})}),"\n",(0,o.jsx)(n.h2,{id:"implementation-in-simulation-and-real-robots",children:"Implementation in Simulation and Real Robots"}),"\n",(0,o.jsx)(n.h3,{id:"simulation-setup",children:"Simulation Setup"}),"\n",(0,o.jsx)(n.p,{children:"When implementing these algorithms in simulation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class SimulatorIntegration:\n    def __init__(self, robot_model, controller):\n        self.robot = robot_model\n        self.controller = controller\n        self.simulation_dt = 0.001  # Physics simulation timestep\n        self.control_dt = 0.01      # Controller timestep (100 Hz)\n        \n    def simulation_loop(self, trajectory, duration=10.0):\n        """\n        Run walking simulation with controller\n        """\n        import time\n        \n        sim_time = 0.0\n        control_update_counter = 0\n        \n        while sim_time < duration:\n            # Physics simulation step\n            self.update_physics()\n            \n            # Controller update (less frequent than physics)\n            if control_update_counter % int(self.control_dt / self.simulation_dt) == 0:\n                self.update_controller(trajectory, sim_time)\n            \n            # Update simulation time\n            sim_time += self.simulation_dt\n            control_update_counter += 1\n            \n            # Optionally, add real-time factor\n            # time.sleep(0.0005)  # For real-time visualization\n        \n        return self.get_final_state()\n    \n    def update_controller(self, trajectory, sim_time):\n        """\n        Update controller with current robot state\n        """\n        # Get current robot state from simulation\n        current_state = self.get_robot_state()\n        \n        # Calculate control commands based on desired trajectory\n        control_commands = self.controller.calculate_control_commands(\n            current_state, \n            self.get_trajectory_reference(sim_time, trajectory)\n        )\n        \n        # Apply control commands to robot in simulation\n        self.apply_control_commands(control_commands)\n    \n    def get_robot_state(self):\n        """\n        Get current state of robot from simulation\n        """\n        # This would interface with the physics engine\n        state = {\n            \'com_position\': self.robot.get_com_position(),\n            \'com_velocity\': self.robot.get_com_velocity(),\n            \'joint_positions\': self.robot.get_joint_positions(),\n            \'joint_velocities\': self.robot.get_joint_velocities(),\n            \'foot_positions\': self.robot.get_foot_positions(),\n            \'imu_data\': self.robot.get_imu_data()\n        }\n        return state\n    \n    def apply_control_commands(self, commands):\n        """\n        Apply calculated control commands to robot\n        """\n        # Send commands to simulation robot model\n        for joint_name, torque in commands.items():\n            self.robot.apply_torque(joint_name, torque)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"balance-recovery-strategies",children:"Balance Recovery Strategies"}),"\n",(0,o.jsx)(n.h3,{id:"disturbance-response",children:"Disturbance Response"}),"\n",(0,o.jsx)(n.p,{children:"Humanoid robots need to handle unexpected disturbances during walking:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class BalanceRecovery:\n    def __init__(self, robot_params):\n        self.params = robot_params\n        self.state_estimator = StateEstimator()\n        self.recovery_strategies = self.define_recovery_strategies()\n        \n    def define_recovery_strategies(self):\n        \"\"\"\n        Define various balance recovery strategies\n        \"\"\"\n        return {\n            'ankle_strategy': {\n                'activation_threshold': 0.05,  # meters COM displacement\n                'duration': 0.1,  # seconds\n                'effort': 'low'\n            },\n            'hip_strategy': {\n                'activation_threshold': 0.10,\n                'duration': 0.2,\n                'effort': 'medium'\n            },\n            'stepping_strategy': {\n                'activation_threshold': 0.15,\n                'duration': 0.3,\n                'effort': 'high'\n            },\n            'grabbing_strategy': {\n                'activation_threshold': 0.20,\n                'duration': 0.5,\n                'effort': 'environment_dependent'\n            }\n        }\n    \n    def assess_disturbance_and_react(self, current_state, disturbance_force):\n        \"\"\"\n        Assess disturbance magnitude and apply appropriate recovery\n        \"\"\"\n        # Estimate state and calculate stability metrics\n        estimated_state = self.state_estimator.estimate_state(current_state)\n        \n        # Calculate disturbance effect on COM\n        com_displacement = self.calculate_com_effect(disturbance_force, estimated_state)\n        \n        # Select appropriate recovery strategy based on displacement\n        for strategy_name, strategy_params in sorted(\n            self.recovery_strategies.items(), \n            key=lambda x: x[1]['activation_threshold']\n        ):\n            if com_displacement > strategy_params['activation_threshold']:\n                print(f\"Activating {strategy_name} for disturbance recovery\")\n                return self.execute_recovery_strategy(strategy_name, current_state)\n        \n        return current_state  # No recovery needed\n    \n    def calculate_com_effect(self, force, state):\n        \"\"\"\n        Calculate COM displacement caused by disturbance force\n        \"\"\"\n        # Simplified model: impulse leads to COM displacement\n        # In reality, this would consider full dynamics\n        impulse = np.linalg.norm(force) * 0.01  # Assuming 0.01s duration\n        mass = self.params['total_mass']\n        acceleration = impulse / mass\n        displacement = 0.5 * acceleration * (0.1**2)  # Assuming 0.1s to react\n        \n        return displacement\n    \n    def execute_recovery_strategy(self, strategy_name, current_state):\n        \"\"\"\n        Execute the specified balance recovery strategy\n        \"\"\"\n        if strategy_name == 'ankle_strategy':\n            return self.ankle_balance_adjustment(current_state)\n        elif strategy_name == 'hip_strategy':\n            return self.hip_balance_adjustment(current_state)\n        elif strategy_name == 'stepping_strategy':\n            return self.emergency_stepping(current_state)\n        elif strategy_name == 'grabbing_strategy':\n            return self.emergency_grabbing(current_state)\n        else:\n            return current_state\n    \n    def ankle_balance_adjustment(self, current_state):\n        \"\"\"\n        Shift balance using ankle joint torques\n        \"\"\"\n        # Calculate required ankle torque to shift COM back\n        current_com = current_state['com_position']\n        desired_com = current_state['desired_com_position']  # Target position\n        \n        # PID control for ankle strategy\n        kp = 200.0  # High gain for quick response\n        kd = 50.0\n        \n        pos_error = desired_com - current_com\n        # For ankle strategy, only adjust in sagittal and coronal planes\n        \n        # Calculate required ankle torques\n        ankle_torques = {\n            'left_ankle_pitch': kp * pos_error[0] * 0.5,  # Forward/back\n            'left_ankle_roll': kp * pos_error[1] * 0.3,   # Side to side\n            'right_ankle_pitch': kp * pos_error[0] * 0.5,\n            'right_ankle_roll': kp * pos_error[1] * 0.3\n        }\n        \n        return ankle_torques\n    \n    def hip_balance_adjustment(self, current_state):\n        \"\"\"\n        Use hip torques for balance recovery\n        \"\"\"\n        # More aggressive than ankle strategy - use hip joints\n        current_com = current_state['com_position']\n        desired_com = current_state['desired_com_position']\n        \n        pos_error = desired_com - current_com\n        \n        # Calculate hip torques needed\n        hip_torques = {\n            'left_hip_pitch': 150.0 * pos_error[0] + 40.0 * current_state['com_velocity'][0],\n            'left_hip_roll': 100.0 * pos_error[1] + 30.0 * current_state['com_velocity'][1],\n            'left_hip_yaw': 50.0 * pos_error[1] * 0.1,  # Small correction\n            'right_hip_pitch': 150.0 * pos_error[0] + 40.0 * current_state['com_velocity'][0],\n            'right_hip_roll': 100.0 * pos_error[1] + 30.0 * current_state['com_velocity'][1],\n            'right_hip_yaw': 50.0 * pos_error[1] * 0.1\n        }\n        \n        return hip_torques\n    \n    def emergency_stepping(self, current_state):\n        \"\"\"\n        Execute emergency step to expand support polygon\n        \"\"\"\n        # Calculate where to step based on COM position\n        current_com = current_state['com_position']\n        current_support_center = self.calculate_support_center(current_state)\n        \n        # Determine step location to bring COM back to stability\n        capture_point = self.estimate_capture_point(current_com, current_state['com_velocity'])\n        \n        step_location = self.calculate_emergency_step_position(\n            current_support_center, capture_point\n        )\n        \n        # Generate step trajectory\n        step_trajectory = self.generate_emergency_step_trajectory(\n            current_state['swing_foot_position'], \n            step_location\n        )\n        \n        return {\n            'step_trajectory': step_trajectory,\n            'early_termination': True,\n            'adjust_support_polygon': True\n        }\n    \n    def estimate_capture_point(self, com_pos, com_vel):\n        \"\"\"\n        Estimate capture point where to step to stop motion\n        \"\"\"\n        h = self.params['com_height']\n        g = 9.81\n        omega = np.sqrt(g / h)\n        \n        cp_x = com_pos[0] + com_vel[0] / omega\n        cp_y = com_pos[1] + com_vel[1] / omega\n        \n        return np.array([cp_x, cp_y, 0.0])\n    \n    def calculate_emergency_step_position(self, current_support, desired_capture_point):\n        \"\"\"\n        Calculate optimal emergency step position\n        \"\"\"\n        # For emergency step, go beyond the capture point to ensure stability\n        safety_margin = 0.1  # 10cm beyond capture point\n        \n        step_x = desired_capture_point[0] + np.sign(desired_capture_point[0] - current_support[0]) * safety_margin\n        step_y = desired_capture_point[1] + np.sign(desired_capture_point[1] - current_support[1]) * safety_margin\n        \n        return np.array([step_x, step_y, 0.0])\n"})}),"\n",(0,o.jsx)(n.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,o.jsx)(n.h3,{id:"issue-1-walking-instability",children:"Issue 1: Walking Instability"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Symptoms"}),": Robot falls during walking, oscillating motion"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Solutions"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Verify COM height estimate accuracy"}),"\n",(0,o.jsx)(n.li,{children:"Adjust ZMP tracking gains"}),"\n",(0,o.jsx)(n.li,{children:"Increase stance phase duration"}),"\n",(0,o.jsx)(n.li,{children:"Check feet friction parameters"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"issue-2-foot-slipping",children:"Issue 2: Foot Slipping"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Symptoms"}),": Feet slide during stepping or stance phases"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Solutions"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Increase friction coefficients in simulation"}),"\n",(0,o.jsx)(n.li,{children:"Reduce step length and speed"}),"\n",(0,o.jsx)(n.li,{children:"Add ankle stiffness control"}),"\n",(0,o.jsx)(n.li,{children:"Verify foot geometry and contact points"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"issue-3-excessive-joint-torques",children:"Issue 3: Excessive Joint Torques"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Symptoms"}),": Unnatural joint movements, potential damage in real robots"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Solutions"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Limit control gains to reasonable values"}),"\n",(0,o.jsx)(n.li,{children:"Add torque saturation"}),"\n",(0,o.jsx)(n.li,{children:"Implement smooth torque transitions"}),"\n",(0,o.jsx)(n.li,{children:"Verify robot dynamics model accuracy"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"issue-4-zmp-outside-support-polygon",children:"Issue 4: ZMP Outside Support Polygon"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Symptoms"}),": Unstable walking, frequent falls"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Solutions"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Verify ZMP calculation implementation"}),"\n",(0,o.jsx)(n.li,{children:"Improve COM trajectory planning"}),"\n",(0,o.jsx)(n.li,{children:"Increase step frequency during disturbances"}),"\n",(0,o.jsx)(n.li,{children:"Implement faster balance recovery strategies"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Gradual Complexity"}),": Start with simple standing balance before attempting walking"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Parameter Tuning"}),": Use system identification techniques to determine optimal gains"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Safety First"}),": Always implement emergency stop procedures"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Simulation-to-Real"}),": Validate controllers in simulation before real robot testing"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Modular Design"}),": Separate balance control, gait generation, and motor control"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Real-time Performance"}),": Optimize algorithms for real-time execution constraints"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sensor Fusion"}),": Use multiple sensors for robust state estimation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Robust Control"}),": Implement controllers that handle parameter uncertainties"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Energy Efficiency"}),": Optimize trajectories for minimal energy consumption"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Continuous Monitoring"}),": Implement comprehensive monitoring and logging"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"Bipedal locomotion and balance control represents one of the most challenging and rewarding areas in humanoid robotics. The complex interplay between mechanical design, control theory, and biological inspiration creates a rich field for innovation and development."}),"\n",(0,o.jsx)(n.p,{children:"Successfully implementing bipedal walking requires:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Understanding inverted pendulum dynamics and ZMP theory"}),"\n",(0,o.jsx)(n.li,{children:"Developing robust balance control strategies"}),"\n",(0,o.jsx)(n.li,{children:"Creating adaptive gait generation algorithms"}),"\n",(0,o.jsx)(n.li,{children:"Implementing efficient real-time control systems"}),"\n",(0,o.jsx)(n.li,{children:"Integrating multiple sensors for state estimation"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"These capabilities form the foundation for humanoid robots to operate effectively in human environments, bridging digital AI models with physical robotic bodies. The field continues to advance with new control techniques, better mechanical designs, and more sophisticated algorithms, bringing us closer to truly human-like robot locomotion."})]})}function _(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453(e,n,t){t.d(n,{R:()=>s,x:()=>a});var o=t(6540);const r={},i=o.createContext(r);function s(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);