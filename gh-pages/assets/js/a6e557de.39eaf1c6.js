"use strict";(globalThis.webpackChunkphysical_ai_curriculum_book=globalThis.webpackChunkphysical_ai_curriculum_book||[]).push([[77],{2389(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var i=t(4848),o=t(8453);const s={sidebar_position:1},a="Humanoid Kinematics and Dynamics",r={id:"module-3-ai-brain/week-11-12/humanoid-dynamics",title:"Humanoid Kinematics and Dynamics",description:"Introduction to Humanoid Robotics",source:"@site/docs/module-3-ai-brain/week-11-12/humanoid-dynamics.md",sourceDirName:"module-3-ai-brain/week-11-12",slug:"/module-3-ai-brain/week-11-12/humanoid-dynamics",permalink:"/physical-ai-curriculum-book/docs/module-3-ai-brain/week-11-12/humanoid-dynamics",draft:!1,unlisted:!1,editUrl:"https://github.com/Anam-Noman/physical-ai-curriculum-book/edit/main/docs/module-3-ai-brain/week-11-12/humanoid-dynamics.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"curriculumSidebar",previous:{title:"Module 3 Summary and Assessment",permalink:"/physical-ai-curriculum-book/docs/module-3-ai-brain/summary"},next:{title:"Bipedal Locomotion and Balance",permalink:"/physical-ai-curriculum-book/docs/module-3-ai-brain/week-11-12/locomotion-balance"}},l={},c=[{value:"Introduction to Humanoid Robotics",id:"introduction-to-humanoid-robotics",level:2},{value:"Humanoid Robot Anatomy",id:"humanoid-robot-anatomy",level:2},{value:"Joint Configuration",id:"joint-configuration",level:3},{value:"Degrees of Freedom",id:"degrees-of-freedom",level:3},{value:"Example Humanoid Structure",id:"example-humanoid-structure",level:3},{value:"Kinematic Analysis",id:"kinematic-analysis",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Dynamics Analysis",id:"dynamics-analysis",level:2},{value:"Rigid Body Dynamics",id:"rigid-body-dynamics",level:3},{value:"Balance and Stability",id:"balance-and-stability",level:2},{value:"Center of Mass (COM) Control",id:"center-of-mass-com-control",level:3},{value:"Walking Gaits and Locomotion",id:"walking-gaits-and-locomotion",level:2},{value:"Bipedal Walking Dynamics",id:"bipedal-walking-dynamics",level:3},{value:"Control Strategies",id:"control-strategies",level:2},{value:"Operational Space Control",id:"operational-space-control",level:3},{value:"Simulation Considerations",id:"simulation-considerations",level:2},{value:"Physics Simulation for Humanoid Robots",id:"physics-simulation-for-humanoid-robots",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Issue 1: Joint Limit Violations",id:"issue-1-joint-limit-violations",level:3},{value:"Issue 2: Balance Instability",id:"issue-2-balance-instability",level:3},{value:"Issue 3: Inverse Kinematics Failures",id:"issue-3-inverse-kinematics-failures",level:3},{value:"Issue 4: Dynamic Instability",id:"issue-4-dynamic-instability",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"humanoid-kinematics-and-dynamics",children:"Humanoid Kinematics and Dynamics"}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-humanoid-robotics",children:"Introduction to Humanoid Robotics"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid robots are designed to mimic the physical structure and movement patterns of humans, making them particularly suitable for human-centered environments. Understanding the kinematics and dynamics of humanoid robots is crucial for developing effective control strategies and achieving natural, stable movement patterns."}),"\n",(0,i.jsx)(e.p,{children:"The kinematics and dynamics of humanoid robots present unique challenges compared to wheeled or simpler robotic systems due to their complex multi-link structure, multiple degrees of freedom (DOF), and the need to maintain balance during locomotion. These systems must address both kinematic constraints (how the robot can move) and dynamic considerations (forces and torques required for movement)."}),"\n",(0,i.jsx)(e.h2,{id:"humanoid-robot-anatomy",children:"Humanoid Robot Anatomy"}),"\n",(0,i.jsx)(e.h3,{id:"joint-configuration",children:"Joint Configuration"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid robots typically feature a structure with:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Trunk"}),": Torso with neck, shoulders, and pelvis"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Upper extremities"}),": Arms with shoulder, elbow, and wrist joints"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Lower extremities"}),": Legs with hip, knee, and ankle joints"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"End effectors"}),": Hands and feet"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"This configuration results in a complex kinematic chain with multiple closed loops when in contact with the environment."}),"\n",(0,i.jsx)(e.h3,{id:"degrees-of-freedom",children:"Degrees of Freedom"}),"\n",(0,i.jsx)(e.p,{children:"A typical humanoid robot has 20-40 degrees of freedom:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Legs (each)"}),": 6 DOF (hip: 3 DOF, knee: 1 DOF, ankle: 2 DOF)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Arms (each)"}),": 7 DOF (shoulder: 3 DOF, elbow: 1 DOF, wrist: 2 DOF, hand: 1 DOF minimum)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Trunk"}),": 3-6 DOF depending on torso flexibility"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Head/Neck"}),": 2-3 DOF"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"example-humanoid-structure",children:"Example Humanoid Structure"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"        Head (2 DOF yaw/pitch)\n         |\n      Neck/Trunk (3-6 DOF)\n      /            \\\\\n     /              \\\\\nShoulders (3 DOF each)  Pelvis\n    |                     |\nArms (3 DOF each)     Legs (6 DOF each)\n    |                     |\nHands                Feet\n"})}),"\n",(0,i.jsx)(e.h2,{id:"kinematic-analysis",children:"Kinematic Analysis"}),"\n",(0,i.jsx)(e.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,i.jsx)(e.p,{children:"Forward kinematics calculates the position and orientation of end-effectors given joint angles. For humanoid robots, this involves multiple kinematic chains:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass HumanoidFK:\n    def __init__(self):\n        # Define DH parameters or transformation matrices for each limb\n        self.left_arm_chain = [\n            {'type': 'rotation', 'axis': 'z', 'offset': [0, 0, 0.15]},  # Shoulder Z rotation\n            {'type': 'rotation', 'axis': 'y', 'offset': [0.1, 0, 0]},  # Shoulder Y rotation  \n            {'type': 'rotation', 'axis': 'x', 'offset': [0.1, 0, 0]},  # Shoulder X rotation\n            {'type': 'rotation', 'axis': 'x', 'offset': [0.3, 0, 0]},  # Elbow X rotation\n            {'type': 'rotation', 'axis': 'z', 'offset': [0.3, 0, 0]},  # Wrist Z rotation\n            {'type': 'rotation', 'axis': 'y', 'offset': [0.1, 0, 0]}   # Wrist Y rotation\n        ]\n        \n        self.right_arm_chain = self.left_arm_chain.copy()  # Mirror for right arm\n        self.left_leg_chain = [\n            {'type': 'rotation', 'axis': 'z', 'offset': [0, 0.1, -0.05]},  # Hip Z\n            {'type': 'rotation', 'axis': 'y', 'offset': [0, 0, -0.05]},    # Hip Y\n            {'type': 'rotation', 'axis': 'x', 'offset': [0, 0, -0.2]},     # Hip X\n            {'type': 'rotation', 'axis': 'x', 'offset': [0, 0, -0.2]},     # Knee X\n            {'type': 'rotation', 'axis': 'z', 'offset': [0, 0, -0.1]},     # Ankle Z\n            {'type': 'rotation', 'axis': 'x', 'offset': [0, 0, -0.05]}     # Ankle X\n        ]\n\n    def transform_point(self, point, axis, angle, offset):\n        \"\"\"\n        Apply rotation and translation to a point\n        \"\"\"\n        # Apply rotation\n        if axis == 'x':\n            R_axis = R.from_euler('x', angle).as_matrix()\n        elif axis == 'y':\n            R_axis = R.from_euler('y', angle).as_matrix()\n        elif axis == 'z':\n            R_axis = R.from_euler('z', angle).as_matrix()\n        else:\n            R_axis = np.eye(3)\n        \n        rotated_point = np.dot(R_axis, point)\n        \n        # Apply translation\n        translated_point = rotated_point + offset\n        return translated_point\n\n    def forward_kinematics_arm(self, joint_angles, chain_def, start_pos=None):\n        \"\"\"\n        Calculate forward kinematics for an arm chain\n        joint_angles: list of joint angles in radians\n        \"\"\"\n        if start_pos is None:\n            start_pos = np.array([0.0, 0.0, 0.0])\n        \n        current_pos = start_pos.copy()\n        current_rotation = np.eye(3)\n        \n        all_positions = [current_pos.copy()]\n        \n        for i, (angle, joint_def) in enumerate(zip(joint_angles, chain_def)):\n            # Apply rotation\n            if joint_def['type'] == 'rotation':\n                if joint_def['axis'] == 'x':\n                    rot_matrix = R.from_euler('x', angle).as_matrix()\n                elif joint_def['axis'] == 'y':\n                    rot_matrix = R.from_euler('y', angle).as_matrix()\n                elif joint_def['axis'] == 'z':\n                    rot_matrix = R.from_euler('z', angle).as_matrix()\n                else:\n                    rot_matrix = np.eye(3)\n                \n                # Update rotation matrix\n                current_rotation = np.dot(current_rotation, rot_matrix)\n                \n                # Translate by the joint offset\n                offset = np.array(joint_def['offset'])\n                current_pos += np.dot(current_rotation, offset)\n            \n            all_positions.append(current_pos.copy())\n        \n        return all_positions\n\n    def calculate_hand_position(self, left_arm_angles, right_arm_angles):\n        \"\"\"\n        Calculate hand positions given arm joint angles\n        \"\"\"\n        # Calculate left hand position using torso as origin\n        left_start = np.array([-0.1, 0.2, 0.8])  # Position of left shoulder\n        left_positions = self.forward_kinematics_arm(left_arm_angles, self.left_arm_chain, left_start)\n        \n        # Calculate right hand position\n        right_start = np.array([0.1, 0.2, 0.8])  # Position of right shoulder\n        right_positions = self.forward_kinematics_arm(right_arm_angles, self.right_arm_chain, right_start)\n        \n        return {\n            'left_hand': left_positions[-1],  # Last position is end effector\n            'right_hand': right_positions[-1],\n            'left_arm_chain': left_positions,\n            'right_arm_chain': right_positions\n        }\n"})}),"\n",(0,i.jsx)(e.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,i.jsx)(e.p,{children:"Inverse kinematics (IK) solves the more complex problem of calculating joint angles needed to position end-effectors at desired locations. Humanoid robots require sophisticated IK solvers due to their redundant structure and multiple kinematic chains."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.transform import Rotation as R\n\nclass HumanoidIK:\n    def __init__(self, robot_config):\n        self.config = robot_config\n        self.fk_solver = HumanoidFK()  # Forward kinematics helper\n        \n    def jacobian_transpose_method(self, chain_def, joint_angles, target_pos, end_effector_idx=-1):\n        \"\"\"\n        Calculate Jacobian transpose for inverse kinematics\n        \"\"\"\n        # Calculate current end effector position\n        chain_positions = self.fk_solver.forward_kinematics_arm(joint_angles, chain_def)\n        current_pos = chain_positions[end_effector_idx]\n        \n        # Calculate error\n        error = target_pos - current_pos\n        \n        # Calculate Jacobian using finite differences\n        delta = 1e-6\n        jacobian = np.zeros((3, len(joint_angles)))  # 3D position, n joints\n        \n        for i in range(len(joint_angles)):\n            # Perturb joint angle\n            perturbed_angles = joint_angles.copy()\n            perturbed_angles[i] += delta\n            \n            # Calculate perturbed position\n            perturbed_chain = self.fk_solver.forward_kinematics_arm(perturbed_angles, chain_def)\n            perturbed_pos = perturbed_chain[end_effector_idx]\n            \n            # Calculate derivative\n            jacobian[:, i] = (perturbed_pos - current_pos) / delta\n        \n        # Calculate joint angle adjustments using Jacobian transpose\n        joint_deltas = np.dot(jacobian.T, error)\n        \n        return joint_deltas, error\n\n    def solve_arm_ik(self, target_pos, initial_angles, chain_def, max_iterations=1000, tolerance=1e-4):\n        \"\"\"\n        Solve inverse kinematics for an arm using iterative Jacobian transpose method\n        \"\"\"\n        current_angles = np.array(initial_angles)\n        \n        for iteration in range(max_iterations):\n            # Calculate current hand position\n            chain_positions = self.fk_solver.forward_kinematics_arm(current_angles, chain_def)\n            current_pos = chain_positions[-1]  # End effector\n            \n            # Calculate error\n            error = np.linalg.norm(target_pos - current_pos)\n            \n            if error < tolerance:\n                print(f\"IK converged after {iteration} iterations\")\n                return current_angles, True\n            \n            # Calculate Jacobian transpose solution\n            joint_deltas, _ = self.jacobian_transpose_method(chain_def, current_angles, target_pos)\n            \n            # Apply small step toward solution\n            step_size = min(0.1, 0.01 / (iteration + 1))\n            current_angles += step_size * joint_deltas\n            \n            # Apply joint limits\n            current_angles = np.clip(current_angles, \n                                   self.config['joint_limits']['min'], \n                                   self.config['joint_limits']['max'])\n        \n        print(f\"IK did not converge after {max_iterations} iterations, error: {error}\")\n        return current_angles, False\n\n    def full_body_ik(self, constraints):\n        \"\"\"\n        Solve full body IK with multiple end-effector constraints\n        constraints: dictionary with desired positions for various end effectors\n        \"\"\"\n        # Objective function to minimize\n        def objective(joint_angles_flat):\n            total_error = 0.0\n            \n            # Reshape flat angles to original structure\n            angles = self.reshape_joint_angles(joint_angles_flat)\n            \n            # Calculate each constraint error\n            if 'left_hand' in constraints:\n                left_hand_chain = self.fk_solver.forward_kinematics_arm(\n                    angles['left_arm'], self.fk_solver.left_arm_chain, \n                    np.array([-0.1, 0.2, 0.8])\n                )\n                left_hand_pos = left_hand_chain[-1]\n                total_error += np.linalg.norm(left_hand_pos - constraints['left_hand'])\n            \n            if 'right_hand' in constraints:\n                right_hand_chain = self.fk_solver.forward_kinematics_arm(\n                    angles['right_arm'], self.fk_solver.right_arm_chain, \n                    np.array([0.1, 0.2, 0.8])\n                )\n                right_hand_pos = right_hand_chain[-1]\n                total_error += np.linalg.norm(right_hand_pos - constraints['right_hand'])\n            \n            if 'left_foot' in constraints:\n                # Similar for left foot\n                pass\n            \n            if 'right_foot' in constraints:\n                # Similar for right foot\n                pass\n            \n            # Add regularization to avoid unnatural poses\n            regularization = 0.01 * np.sum((joint_angles_flat - self.config['neutral_pose'])**2)\n            \n            return total_error + regularization\n        \n        # Initial guess (start from neutral pose)\n        initial_flat = self.flatten_joint_angles(self.config['neutral_pose'])\n        \n        # Optimize using scipy\n        result = minimize(objective, initial_flat, method='BFGS')\n        \n        optimized_angles = self.reshape_joint_angles(result.x)\n        \n        return optimized_angles, result.success\n\n    def reshape_joint_angles(self, flat_angles):\n        \"\"\"Convert flat array back to structured joint angles\"\"\"\n        # Implementation depends on your joint organization\n        return {'left_arm': flat_angles[:6], 'right_arm': flat_angles[6:12]}\n    \n    def flatten_joint_angles(self, structured_angles):\n        \"\"\"Convert structured joint angles to flat array\"\"\"\n        # Implementation depends on your joint organization\n        flat = np.concatenate([\n            structured_angles['left_arm'],\n            structured_angles['right_arm']\n        ])\n        return flat\n"})}),"\n",(0,i.jsx)(e.h2,{id:"dynamics-analysis",children:"Dynamics Analysis"}),"\n",(0,i.jsx)(e.h3,{id:"rigid-body-dynamics",children:"Rigid Body Dynamics"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid robots are multi-rigid-body systems with complex dynamic interactions. The equations of motion for such systems are derived from Newton-Euler or Lagrangian mechanics."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class HumanoidDynamics:\n    def __init__(self, robot_params):\n        self.params = robot_params\n        self.mass_matrix = self.calculate_mass_matrix()\n        self.coriolis_matrix = self.calculate_coriolis_matrix()\n        self.gravity_vector = self.calculate_gravity_vector()\n        \n    def lagrangian_equation(self, q, q_dot, tau):\n        """\n        Calculate dynamics using Lagrangian formulation:\n        M(q)*q_ddot + C(q,q_dot)*q_dot + G(q) = tau\n        where q = joint angles, q_dot = joint velocities, tau = joint torques\n        """\n        # Calculate mass matrix M(q)\n        M = self.calculate_mass_matrix(q)\n        \n        # Calculate Coriolis and centrifugal matrix C(q, q_dot)\n        C = self.calculate_coriolis_matrix(q, q_dot)\n        \n        # Calculate gravity vector G(q)\n        G = self.calculate_gravity_vector(q)\n        \n        # Calculate joint accelerations: M*q_ddot = tau - C*q_dot - G\n        q_ddot = np.linalg.solve(M, tau - np.dot(C, q_dot) - G)\n        \n        return q_ddot\n    \n    def calculate_mass_matrix(self, q=None):\n        """\n        Calculate the mass (inertia) matrix using recursive Newton-Euler algorithm\n        """\n        # Simplified implementation - full implementation would be more complex\n        n_joints = len(self.params[\'links\'])\n        M = np.zeros((n_joints, n_joints))\n        \n        # This is a simplified version - real implementation would calculate\n        # the full mass matrix accounting for coupled dynamics between joints\n        for i in range(n_joints):\n            M[i, i] = self.params[\'links\'][i][\'mass\']  # Diagonal terms\n            \n        return M\n    \n    def calculate_coriolis_matrix(self, q, q_dot):\n        """\n        Calculate Coriolis and centrifugal forces matrix\n        """\n        n_joints = len(q)\n        C = np.zeros((n_joints, n_joints))\n        \n        # Simplified: in reality, this involves complex coupling terms\n        # between all joints based on current configuration and velocities\n        for i in range(n_joints):\n            for j in range(n_joints):\n                # Calculate Coriolis terms (simplified)\n                C[i, j] = 0.1 * q_dot[j] if i != j else 0.05 * q_dot[i]\n        \n        return C\n    \n    def calculate_gravity_vector(self, q):\n        """\n        Calculate gravity forces vector\n        """\n        n_joints = len(q)\n        G = np.zeros(n_joints)\n        \n        # Calculate gravity contribution of each link\n        for i in range(n_joints):\n            link = self.params[\'links\'][i]\n            # Gravity component depends on link\'s position and orientation\n            G[i] = link[\'mass\'] * 9.81 * np.sin(q[i])  # Simplified\n        \n        return G\n\n    def forward_dynamics(self, q, q_dot, tau):\n        """\n        Forward dynamics: given positions, velocities and torques, \n        calculate accelerations\n        """\n        return self.lagrangian_equation(q, q_dot, tau)\n    \n    def inverse_dynamics(self, q, q_dot, q_ddot):\n        """\n        Inverse dynamics: given positions, velocities and accelerations, \n        calculate required torques\n        """\n        M = self.calculate_mass_matrix(q)\n        C = self.calculate_coriolis_matrix(q, q_dot)\n        G = self.calculate_gravity_vector(q)\n        \n        # Calculate required torques: tau = M*q_ddot + C*q_dot + G\n        tau = np.dot(M, q_ddot) + np.dot(C, q_dot) + G\n        \n        return tau\n'})}),"\n",(0,i.jsx)(e.h2,{id:"balance-and-stability",children:"Balance and Stability"}),"\n",(0,i.jsx)(e.h3,{id:"center-of-mass-com-control",children:"Center of Mass (COM) Control"}),"\n",(0,i.jsx)(e.p,{children:"Maintaining balance requires careful control of the center of mass relative to the support polygon formed by the robot's contact points:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class BalanceController:\n    def __init__(self, robot_params):\n        self.robot_params = robot_params\n        self.com_position = np.array([0.0, 0.0, 0.0])\n        self.com_velocity = np.array([0.0, 0.0, 0.0])\n        self.desired_com = np.array([0.0, 0.0, 0.8])  # Desired COM height\n        self.com_pid = PIDController(kp=100.0, ki=1.0, kd=10.0)\n        \n    def is_stable(self, com_pos, support_polygon):\n        """\n        Check if center of mass is within support polygon\n        """\n        # Calculate projection of COM onto ground plane\n        com_xy = com_pos[:2]\n        \n        # Check if COM projection is inside support polygon\n        return self.point_in_polygon(com_xy, support_polygon)\n    \n    def point_in_polygon(self, point, polygon):\n        """\n        Check if a point is inside a polygon using ray casting\n        """\n        x, y = point\n        n = len(polygon)\n        inside = False\n        \n        p1x, p1y = polygon[0]\n        for i in range(1, n + 1):\n            p2x, p2y = polygon[i % n]\n            if y > min(p1y, p2y):\n                if y <= max(p1y, p2y):\n                    if x <= max(p1x, p2x):\n                        if p1y != p2y:\n                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                        if p1x == p2x or x <= xinters:\n                            inside = not inside\n            p1x, p1y = p2x, p2y\n        \n        return inside\n    \n    def calculate_com_position(self, joint_angles, link_masses, link_positions):\n        """\n        Calculate center of mass position given joint configuration\n        """\n        total_mass = sum(link_masses)\n        weighted_sum = np.zeros(3)\n        \n        # Calculate FK for each link to get their positions\n        fk = HumanoidFK()\n        chain_positions = fk.calculate_hand_position([], [])  # Placeholder\n        \n        # In practice, you would calculate the position of each individual link\n        # using forward kinematics and then compute COM\n        \n        # Simplified calculation\n        for mass, pos in zip(link_masses, link_positions):\n            weighted_sum += mass * np.array(pos)\n        \n        com_pos = weighted_sum / total_mass\n        return com_pos\n    \n    def calculate_support_polygon(self, feet_positions):\n        """\n        Calculate support polygon from current foot positions\n        """\n        if len(feet_positions) == 0:\n            return []\n        \n        # If both feet are on ground, create polygon from foot positions\n        if len(feet_positions) >= 2:\n            # Calculate convex hull of foot positions\n            import scipy.spatial\n            hull = scipy.spatial.ConvexHull(np.array(feet_positions)[:, :2])\n            return np.array(feet_positions)[hull.vertices][:, :2]\n        else:\n            # Single foot support - use foot\'s contact area\n            return self.calculate_foot_support_area(feet_positions[0])\n    \n    def calculate_foot_support_area(self, foot_position):\n        """\n        Calculate support area for single foot\n        """\n        # Simplified: assume rectangular foot with small support area\n        length = 0.2  # Foot length\n        width = 0.1   # Foot width\n        \n        return np.array([\n            [foot_position[0] - length/2, foot_position[1] - width/2],\n            [foot_position[0] + length/2, foot_position[1] - width/2],\n            [foot_position[0] + length/2, foot_position[1] + width/2],\n            [foot_position[0] - length/2, foot_position[1] + width/2]\n        ])\n    \n    def balance_control_step(self, current_com_pos, support_polygon):\n        """\n        Calculate balance control commands to keep robot stable\n        """\n        # Check if COM is within support polygon\n        stable = self.is_stable(current_com_pos, support_polygon)\n        \n        if not stable:\n            # Calculate desired COM adjustment to move inside support polygon\n            desired_adjustment = self.calculate_balance_correction(\n                current_com_pos, support_polygon\n            )\n        else:\n            # Maintain current COM near desired position\n            desired_adjustment = self.desired_com - current_com_pos\n        \n        # Use PID controller to generate control forces\n        control_output = self.com_pid.update(desired_adjustment[:2], current_com_pos[:2])\n        \n        return control_output\n    \n    def calculate_balance_correction(self, com_pos, support_polygon):\n        """\n        Calculate correction to bring COM inside support polygon\n        """\n        com_xy = com_pos[:2]\n        \n        # Find closest point inside polygon\n        if not self.point_in_polygon(com_xy, support_polygon):\n            closest_point = self.find_closest_point_in_polygon(com_xy, support_polygon)\n            correction = closest_point - com_xy\n        else:\n            correction = np.zeros(2)\n        \n        return correction\n    \n    def find_closest_point_in_polygon(self, point, polygon):\n        """\n        Find closest point inside polygon to a given point\n        """\n        # For a point outside the polygon, find the closest edge and project onto it\n        # This is a simplified approach - more sophisticated algorithms exist\n        import scipy.spatial.distance\n        \n        if self.point_in_polygon(point, polygon):\n            return point\n        \n        # For each edge of the polygon, find closest point on the edge\n        min_dist = float(\'inf\')\n        closest_point = point.copy()\n        \n        n = len(polygon)\n        for i in range(n):\n            p1 = polygon[i]\n            p2 = polygon[(i + 1) % n]\n            \n            # Find closest point on line segment\n            closest_on_edge = self.closest_point_on_segment(point, p1, p2)\n            dist = np.linalg.norm(point - closest_on_edge)\n            \n            if dist < min_dist:\n                min_dist = dist\n                closest_point = closest_on_edge\n        \n        return closest_point\n    \n    def closest_point_on_segment(self, point, seg_start, seg_end):\n        """\n        Find closest point on line segment to given point\n        """\n        seg_vec = seg_end - seg_start\n        point_vec = point - seg_start\n        \n        seg_len_sq = np.dot(seg_vec, seg_vec)\n        if seg_len_sq == 0:\n            return seg_start  # Degenerate case\n        \n        t = max(0, min(1, np.dot(point_vec, seg_vec) / seg_len_sq))\n        return seg_start + t * seg_vec\n\nclass PIDController:\n    def __init__(self, kp=1.0, ki=0.0, kd=0.0):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.prev_error = 0\n        self.integral = 0\n    \n    def update(self, desired, actual, dt=0.01):\n        error = desired - actual\n        \n        # Proportional term\n        p_term = self.kp * error\n        \n        # Integral term\n        self.integral += error * dt\n        i_term = self.ki * self.integral\n        \n        # Derivative term\n        derivative = (error - self.prev_error) / dt\n        d_term = self.kd * derivative\n        \n        self.prev_error = error\n        \n        return p_term + i_term + d_term\n'})}),"\n",(0,i.jsx)(e.h2,{id:"walking-gaits-and-locomotion",children:"Walking Gaits and Locomotion"}),"\n",(0,i.jsx)(e.h3,{id:"bipedal-walking-dynamics",children:"Bipedal Walking Dynamics"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid locomotion requires managing complex dynamic interactions and balance during multi-phase walking:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class BipedalWalker:\n    def __init__(self, robot_params):\n        self.params = robot_params\n        self.step_length = 0.3  # meters\n        self.step_height = 0.1  # meters\n        self.step_duration = 1.0  # seconds\n        self.balance_controller = BalanceController(robot_params)\n        \n    def generate_walk_pattern(self, num_steps, step_size=0.3):\n        """\n        Generate walking pattern with alternating steps\n        """\n        walk_pattern = []\n        \n        for i in range(num_steps):\n            # Left foot step (if odd step)\n            if i % 2 == 1:\n                step_pattern = self.generate_single_step(\n                    leg=\'left\', \n                    step_num=i, \n                    step_size=step_size\n                )\n            else:\n                # Right foot step (if even step)\n                step_pattern = self.generate_single_step(\n                    leg=\'right\', \n                    step_num=i, \n                    step_size=step_size\n                )\n            \n            walk_pattern.extend(step_pattern)\n        \n        return walk_pattern\n    \n    def generate_single_step(self, leg, step_num, step_size):\n        """\n        Generate trajectory for a single step\n        """\n        # Calculate step trajectory using sine wave for smooth motion\n        trajectory = []\n        \n        # Step phase duration (assuming 50% stance, 50% swing)\n        step_time = self.step_duration\n        stance_time = step_time * 0.5  # 50% of time in stance phase\n        swing_time = step_time * 0.5   # 50% of time in swing phase\n        \n        # Number of trajectory points\n        num_points = 50\n        \n        # Stance phase (support leg remains on ground)\n        for j in range(num_points//2):\n            t = j * stance_time / (num_points//2)\n            # During stance, support leg stays in place\n            if leg == \'right\':\n                # Left leg is swing leg, right leg is stance leg\n                pos = self.calculate_swing_trajectory(\n                    start_pos=[0, -0.1, 0],  # starting lift position\n                    target_pos=[step_size, -0.1, 0],  # step forward\n                    t=t, total_time=swing_time, phase=\'stance\'\n                )\n            else:\n                # Right leg is swing leg, left leg is stance leg\n                pos = self.calculate_swing_trajectory(\n                    start_pos=[0, 0.1, 0],  # starting lift position\n                    target_pos=[step_size, 0.1, 0],  # step forward\n                    t=t, total_time=swing_time, phase=\'stance\'\n                )\n            \n            trajectory.append(pos)\n        \n        # Swing phase (swing leg moves forward)\n        for j in range(num_points//2):\n            t = j * swing_time / (num_points//2)\n            \n            if leg == \'right\':\n                # Right leg swings forward\n                pos = self.calculate_swing_trajectory(\n                    start_pos=[0, 0.1, 0.05],  # lifted position\n                    target_pos=[step_size, 0.1, 0],  # landed position\n                    t=t, total_time=swing_time, phase=\'swing\'\n                )\n            else:\n                # Left leg swings forward\n                pos = self.calculate_swing_trajectory(\n                    start_pos=[0, -0.1, 0.05],  # lifted position\n                    target_pos=[step_size, -0.1, 0],  # landed position\n                    t=t, total_time=swing_time, phase=\'swing\'\n                )\n            \n            trajectory.append(pos)\n        \n        return trajectory\n    \n    def calculate_swing_trajectory(self, start_pos, target_pos, t, total_time, phase=\'swing\'):\n        """\n        Calculate swing leg trajectory using sinusoidal lift and smooth transition\n        """\n        # Calculate percentage of phase completed\n        progress = min(t / total_time, 1.0)\n        \n        # Calculate intermediate position\n        intermediate_pos = np.array(start_pos) * (1 - progress) + np.array(target_pos) * progress\n        \n        if phase == \'swing\':\n            # Add liftoff and landing curves\n            # Lift leg in middle of swing\n            lift_factor = 0.8 * np.sin(progress * np.pi)  # Sinusoidal lift\n            intermediate_pos[2] += lift_factor * self.step_height\n        \n        return intermediate_pos.tolist()\n    \n    def compute_ik_for_walk(self, walk_trajectory, current_pose):\n        """\n        Compute inverse kinematics for entire walk trajectory\n        """\n        ik_solver = HumanoidIK(self.params)\n        pose_sequence = []\n        \n        for step in walk_trajectory:\n            # Define constraints based on desired foot positions\n            constraints = {}\n            \n            # Example: constrain swing leg to trajectory position\n            # and stance leg to ground contact\n            for i, (leg_name, target_pos) in enumerate(step):\n                constraints[leg_name] = target_pos\n            \n            # Solve full body IK to satisfy constraints\n            optimized_pose, success = ik_solver.full_body_ik(constraints)\n            \n            if success:\n                pose_sequence.append(optimized_pose)\n            else:\n                # Fallback to previous pose if IK fails\n                pose_sequence.append(current_pose if pose_sequence else self.get_neutral_pose())\n        \n        return pose_sequence\n    \n    def implement_zmp_balancing(self, walk_trajectory):\n        """\n        Implement Zero Moment Point (ZMP) balancing for stable walking\n        """\n        # ZMP (Zero Moment Point) is a point where the moment of active and \n        # reactive forces sums to zero\n        zmp_trajectory = []\n        \n        for step in walk_trajectory:\n            # Calculate ZMP based on foot positions and COM dynamics\n            left_foot = step.get(\'left_foot\', [0, -0.1, 0])\n            right_foot = step.get(\'right_foot\', [0, 0.1, 0])\n            \n            # For bipedal walking, ZMP should stay within support polygon\n            # formed by feet contact points\n            if self.is_double_support_phase(left_foot, right_foot):\n                # ZMP should be between feet for double support\n                zmp_x = (left_foot[0] + right_foot[0]) / 2\n                zmp_y = (left_foot[1] + right_foot[1]) / 2\n            else:\n                # ZMP should be near stance foot for single support\n                zmp_x, zmp_y = self.select_stance_foot_zmp(left_foot, right_foot)\n            \n            zmp_trajectory.append([zmp_x, zmp_y])\n        \n        return zmp_trajectory\n    \n    def is_double_support_phase(self, left_foot, right_foot):\n        """\n        Determine if in double support phase based on feet positions\n        """\n        # Simplified check - in reality, this would be based on gait phase\n        return abs(left_foot[0] - right_foot[0]) < 0.1  # Less than 10cm apart\n    \n    def select_stance_foot_zmp(self, left_foot, right_foot):\n        """\n        Select ZMP position near stance foot\n        """\n        # For this example, just return the front foot position\n        # In reality, this would be calculated based on dynamic model\n        return right_foot[0], right_foot[1]  # Assuming right foot is stance foot\n\n    def get_neutral_pose(self):\n        """\n        Return robot\'s neutral standing pose\n        """\n        # Example neutral pose joint angles\n        return {\n            \'left_arm\': [0, 0, 0, 0, 0, 0],\n            \'right_arm\': [0, 0, 0, 0, 0, 0],\n            \'left_leg\': [0, 0, 0, 0, 0, 0],\n            \'right_leg\': [0, 0, 0, 0, 0, 0]\n        }\n'})}),"\n",(0,i.jsx)(e.h2,{id:"control-strategies",children:"Control Strategies"}),"\n",(0,i.jsx)(e.h3,{id:"operational-space-control",children:"Operational Space Control"}),"\n",(0,i.jsx)(e.p,{children:"Operational space control allows specifying task-space behavior (like end-effector position) while dealing with the robot's dynamics properly:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class OperationalSpaceController:\n    def __init__(self, robot_dynamics):\n        self.dynamics = robot_dynamics\n        self.lambda_inv = None  # Inverse of task space inertia\n        self.J = None  # Jacobian matrix\n        self.N = None  # Null space projection matrix\n    \n    def operational_space_control(self, q, q_dot, x_desired, xd_desired, xdd_desired):\n        """\n        Compute operational space control law\n        """\n        # Calculate Jacobian J(q) for the task\n        # This would be specific to your task (e.g., end-effector position)\n        J = self.calculate_jacobian(q)\n        \n        # Calculate Jacobian derivative (needed for acceleration terms)\n        J_dot = self.calculate_jacobian_derivative(q, q_dot)\n        \n        # Calculate mass matrix in task space: Lambda = (J * M^-1 * J^T)^-1\n        M = self.dynamics.calculate_mass_matrix(q)\n        \n        # Use pseudoinverse to handle redundancy\n        J_pinv = np.linalg.pinv(J)\n        Lambda = np.linalg.inv(np.dot(J, np.dot(np.linalg.inv(M), J.T)))\n        \n        # Calculate null space matrix: N = I - J^# * J\n        N = np.eye(len(q)) - np.dot(J_pinv, J)\n        \n        # Calculate operational space acceleration command\n        # x_ddot_cmd = Lambda * (F_task + J * M^-1 * (tau_grav - tau_coriolis))\n        # where F_task = M_task * (xdd_desired + Kd * (xd_desired - x_dot) + Kp * (x_desired - x))\n        \n        # Calculate current task position and velocity\n        x_current = self.forward_kinematics_task(q)\n        xd_current = np.dot(J, q_dot)\n        \n        # Task space PD control\n        Kp = 100.0  # Proportional gain\n        Kd = 20.0   # Derivative gain\n        \n        F_task = (Lambda @ (xdd_desired + \n                   Kp * (x_desired - x_current) + \n                   Kd * (xd_desired - xd_current)))\n        \n        # Calculate gravity and Coriolis compensation in task space\n        tau_grav = self.dynamics.calculate_gravity_vector(q)\n        tau_coriolis = np.dot(self.dynamics.calculate_coriolis_matrix(q, q_dot), q_dot)\n        \n        # Total control law in joint space\n        tau = (np.dot(J.T, F_task) + \n               np.dot(N.T, self.null_space_control(q, q_dot)))\n        \n        return tau\n    \n    def null_space_control(self, q, q_dot):\n        """\n        Control null space motion to achieve secondary objectives\n        (like keeping joints away from limits, or maintaining posture)\n        """\n        q_null_desired = self.get_posture_desired()  # Desired joint configuration\n        \n        # PD control in null space\n        Kp_null = 10.0\n        Kd_null = 2.0\n        \n        tau_null = (Kp_null * (q_null_desired - q) - \n                   Kd_null * q_dot)\n        \n        return tau_null\n    \n    def get_posture_desired(self):\n        """\n        Return desired joint angles for posture control\n        """\n        # Return neutral pose or other desired configuration\n        return np.zeros(len(self.dynamics.params[\'links\']))\n\n# Example of walking pattern generation with balance\ndef generate_stable_walk_trajectory(biped_walker, num_steps):\n    """\n    Generate a stable walking trajectory using balance considerations\n    """\n    # Generate basic walk pattern\n    basic_walk = biped_walker.generate_walk_pattern(num_steps)\n    \n    # Apply ZMP balancing to ensure stability\n    zmp_trajectory = biped_walker.implement_zmp_balancing(basic_walk)\n    \n    # Generate COM trajectory that follows ZMP constraints\n    com_trajectory = biped_walker.calculate_com_trajectory_for_stability(\n        basic_walk, zmp_trajectory\n    )\n    \n    # Apply operational space control for smooth motion\n    osc_controller = OperationalSpaceController(HumanoidDynamics({}))\n    \n    return {\n        \'basic_walk\': basic_walk,\n        \'zmp_trajectory\': zmp_trajectory,\n        \'com_trajectory\': com_trajectory,\n        \'osc_commands\': []  # Would be filled during execution\n    }\n'})}),"\n",(0,i.jsx)(e.h2,{id:"simulation-considerations",children:"Simulation Considerations"}),"\n",(0,i.jsx)(e.h3,{id:"physics-simulation-for-humanoid-robots",children:"Physics Simulation for Humanoid Robots"}),"\n",(0,i.jsx)(e.p,{children:"When simulating humanoid robots, special attention must be paid to:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"class HumanoidSimulator:\n    def __init__(self, robot_model):\n        self.robot = robot_model\n        self.physics_engine = \"PhysX\"  # Or Bullet, ODE, etc.\n        self.contact_models = self.setup_contact_models()\n        \n    def setup_contact_models(self):\n        \"\"\"\n        Set up accurate contact models for feet and hands\n        \"\"\"\n        contact_models = {\n            'feet': {\n                'friction_coefficient': 0.7,  # Typical for shoe-ground\n                'elastic_modulus': 1e6,       # Stiffness parameter\n                'damping_ratio': 0.1,\n                'contact_shape': 'rectangular',  # Foot shape approximation\n                'safety_margin': 0.02  # 2cm safety margin\n            },\n            'hands': {\n                'friction_coefficient': 0.5,  # Grip friction\n                'elastic_modulus': 1e5,       # Softer than feet\n                'damping_ratio': 0.15,\n                'contact_shape': 'ellipsoidal',\n                'safety_margin': 0.01  # 1cm safety margin\n            }\n        }\n        \n        return contact_models\n    \n    def simulate_balance_reactions(self):\n        \"\"\"\n        Simulate balance reactions to unexpected disturbances\n        \"\"\"\n        # Implement balance control during simulation\n        # This would involve running the balance controller from above\n        # in the simulation loop\n        \n        balance_controller = BalanceController(self.robot.model_params)\n        \n        # Simulation loop would call balance controller each step\n        # to adjust robot's pose and maintain balance\n        \n        pass\n    \n    def validate_dynamics_model(self, real_robot_data):\n        \"\"\"\n        Validate simulation dynamics against real robot behavior\n        \"\"\"\n        # Compare simulated and real responses to same inputs\n        # This is important for sim-to-real transfer\n        \n        simulation_response = self.run_simulation_test()\n        real_response = real_robot_data\n        \n        # Calculate similarity metrics\n        position_error = np.mean([\n            np.linalg.norm(sim_pos - real_pos) \n            for sim_pos, real_pos in zip(simulation_response['positions'], \n                                       real_response['positions'])\n        ])\n        \n        velocity_error = np.mean([\n            np.linalg.norm(sim_vel - real_vel) \n            for sim_vel, real_vel in zip(simulation_response['velocities'], \n                                       real_response['velocities'])\n        ])\n        \n        return {\n            'position_accuracy': 1.0 / (1.0 + position_error),\n            'velocity_accuracy': 1.0 / (1.0 + velocity_error),\n            'overall_fidelity': (1.0 / (1.0 + position_error) + \n                               1.0 / (1.0 + velocity_error)) / 2\n        }\n"})}),"\n",(0,i.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,i.jsx)(e.h3,{id:"issue-1-joint-limit-violations",children:"Issue 1: Joint Limit Violations"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Symptoms"}),": Robot joints exceeding physical limits"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Solutions"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Implement joint limit checks in IK solvers"}),"\n",(0,i.jsx)(e.li,{children:"Use constrained optimization techniques"}),"\n",(0,i.jsx)(e.li,{children:"Add joint limit penalty terms to objective functions"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"issue-2-balance-instability",children:"Issue 2: Balance Instability"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Symptoms"}),": Robot falls over during standing or walking"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Solutions"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Implement ZMP-based balance control"}),"\n",(0,i.jsx)(e.li,{children:"Use COM feedback control"}),"\n",(0,i.jsx)(e.li,{children:"Add ankle and hip strategies"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"issue-3-inverse-kinematics-failures",children:"Issue 3: Inverse Kinematics Failures"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Symptoms"}),": IK solver unable to find solution"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Solutions"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Use damped least squares method"}),"\n",(0,i.jsx)(e.li,{children:"Implement multiple strategies (Jacobian transpose, pseudoinverse, etc.)"}),"\n",(0,i.jsx)(e.li,{children:"Check reachability of desired positions"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"issue-4-dynamic-instability",children:"Issue 4: Dynamic Instability"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Symptoms"}),": Unstable motion even when statically balanced"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Solutions"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Verify mass matrix calculation"}),"\n",(0,i.jsx)(e.li,{children:"Check Coriolis and centrifugal terms"}),"\n",(0,i.jsx)(e.li,{children:"Implement proper force control"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Model Validation"}),": Regularly validate simulation models against real robot data"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Safety Margins"}),": Include safety margins in all calculations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Modular Design"}),": Keep kinematic, dynamic, and control modules separate"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Real-time Capability"}),": Optimize algorithms for real-time performance"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Redundancy Management"}),": Effectively use the robot's redundant DOFs"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Robust Control"}),": Implement robust control strategies that handle uncertainties"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Gradual Complexity"}),": Start with simple tasks and gradually increase complexity"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Comprehensive Testing"}),": Test on various terrains and conditions"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid kinematics and dynamics form the foundation for controlling these complex robots. The combination of multiple kinematic chains, balance requirements, and the need to maintain stability during dynamic motions creates unique challenges in control and planning."}),"\n",(0,i.jsx)(e.p,{children:"Understanding both the kinematic relationships (how the robot moves) and dynamic interactions (the forces required for movement) is essential for developing successful humanoid robot controllers. The integration of balance control, walking gaits, and operational space control techniques enables the creation of stable, efficient, and natural-looking humanoid robot behaviors."}),"\n",(0,i.jsx)(e.p,{children:"These principles are fundamental to creating Physical AI systems that can effectively bridge digital AI models with physical humanoid robotic bodies, enabling robots that can interact naturally with human-centered environments."})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>a,x:()=>r});var i=t(6540);const o={},s=i.createContext(o);function a(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);