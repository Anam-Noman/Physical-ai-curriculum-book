"use strict";(globalThis.webpackChunkphysical_ai_curriculum_book=globalThis.webpackChunkphysical_ai_curriculum_book||[]).push([[432],{5690(e,n,i){i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>t,metadata:()=>a,toc:()=>d});var r=i(4848),o=i(8453);const t={sidebar_position:6},l="URDF for Humanoid Robot Structure",a={id:"module-1-ros2/week-3-5/urdf-modeling",title:"URDF for Humanoid Robot Structure",description:"Understanding URDF",source:"@site/docs/module-1-ros2/week-3-5/urdf-modeling.md",sourceDirName:"module-1-ros2/week-3-5",slug:"/module-1-ros2/week-3-5/urdf-modeling",permalink:"/physical-ai-curriculum-book/docs/module-1-ros2/week-3-5/urdf-modeling",draft:!1,unlisted:!1,editUrl:"https://github.com/Anam-Noman/physical-ai-curriculum-book/edit/main/docs/module-1-ros2/week-3-5/urdf-modeling.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"curriculumSidebar",previous:{title:"Python AI Agents to Robot Controllers using rclpy",permalink:"/physical-ai-curriculum-book/docs/module-1-ros2/week-3-5/rclpy-bridge"},next:{title:"Module 2: The Digital Twin (Gazebo & Unity)",permalink:"/physical-ai-curriculum-book/docs/module-2-digital-twin/"}},s={},d=[{value:"Understanding URDF",id:"understanding-urdf",level:2},{value:"What URDF Describes",id:"what-urdf-describes",level:3},{value:"URDF Structure",id:"urdf-structure",level:2},{value:"Robot Element",id:"robot-element",level:3},{value:"Links",id:"links",level:3},{value:"Joints",id:"joints",level:3},{value:"Joint Types",id:"joint-types",level:2},{value:"Fixed Joint",id:"fixed-joint",level:3},{value:"Revolute Joint",id:"revolute-joint",level:3},{value:"Continuous Joint",id:"continuous-joint",level:3},{value:"Prismatic Joint",id:"prismatic-joint",level:3},{value:"Complete URDF Example: Simple Humanoid Robot",id:"complete-urdf-example-simple-humanoid-robot",level:2},{value:"URDF and ROS 2 Integration",id:"urdf-and-ros-2-integration",level:2},{value:"Loading URDF in ROS 2",id:"loading-urdf-in-ros-2",level:3},{value:"Using xacro",id:"using-xacro",level:3},{value:"URDF Best Practices",id:"urdf-best-practices",level:2},{value:"Naming Conventions",id:"naming-conventions",level:3},{value:"Inertial Properties",id:"inertial-properties",level:3},{value:"Visual vs. Collision Models",id:"visual-vs-collision-models",level:3},{value:"Humanoid-Specific Considerations",id:"humanoid-specific-considerations",level:2},{value:"Kinematic Chains",id:"kinematic-chains",level:3},{value:"Degrees of Freedom",id:"degrees-of-freedom",level:3},{value:"Balance and Stability",id:"balance-and-stability",level:3},{value:"Validation and Debugging",id:"validation-and-debugging",level:2},{value:"URDF Validation",id:"urdf-validation",level:3},{value:"Visualization",id:"visualization",level:3},{value:"Advanced URDF Features",id:"advanced-urdf-features",level:2},{value:"Gazebo-Specific Elements",id:"gazebo-specific-elements",level:3},{value:"Transmission Elements",id:"transmission-elements",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"urdf-for-humanoid-robot-structure",children:"URDF for Humanoid Robot Structure"}),"\n",(0,r.jsx)(n.h2,{id:"understanding-urdf",children:"Understanding URDF"}),"\n",(0,r.jsx)(n.p,{children:"The Unified Robot Description Format (URDF) is the standard format for representing robot models in ROS. URDF is an XML-based format that describes a robot's physical and visual properties, including its kinematic structure, inertial properties, visual appearance, and collision properties."}),"\n",(0,r.jsx)(n.p,{children:"URDF serves as the bridge between digital robot models and their physical counterparts, allowing simulation environments and controllers to reason about the robot's structure and capabilities. For humanoid robots, URDF is particularly important as it defines the complex kinematic structure of limbs, joints, and sensors."}),"\n",(0,r.jsx)(n.h3,{id:"what-urdf-describes",children:"What URDF Describes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Kinematic structure"}),": The arrangement of links and joints"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inertial properties"}),": Mass, center of mass, and moments of inertia for each link"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Visual representation"}),": Meshes, colors, and textures for visualization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Collision properties"}),": Shapes used for collision detection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensors"}),": Locations and types of various sensors on the robot"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"urdf-structure",children:"URDF Structure"}),"\n",(0,r.jsx)(n.p,{children:"A URDF file is composed of several main elements:"}),"\n",(0,r.jsx)(n.h3,{id:"robot-element",children:"Robot Element"}),"\n",(0,r.jsxs)(n.p,{children:["The root element of a URDF file is the ",(0,r.jsx)(n.code,{children:"<robot>"})," tag, which contains the entire robot definition:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<robot name="my_robot">\n  \x3c!-- Links and joints go here --\x3e\n</robot>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"links",children:"Links"}),"\n",(0,r.jsx)(n.p,{children:"Links represent the rigid bodies of the robot. Each link contains information about its inertial properties, visual representation, and collision properties:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<link name="link_name">\n  <inertial>\n    <mass value="1.0"/>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\n  </inertial>\n  \n  <visual>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <cylinder length="0.1" radius="0.05"/>\n    </geometry>\n    <material name="blue">\n      <color rgba="0 0 1 1"/>\n    </material>\n  </visual>\n  \n  <collision>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <cylinder length="0.1" radius="0.05"/>\n    </geometry>\n  </collision>\n</link>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"joints",children:"Joints"}),"\n",(0,r.jsx)(n.p,{children:"Joints connect links together and define the kinematic relationships between them:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<joint name="joint_name" type="revolute">\n  <parent link="parent_link_name"/>\n  <child link="child_link_name"/>\n  <origin xyz="0.1 0 0" rpy="0 0 0"/>\n  <axis xyz="0 0 1"/>\n  <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n</joint>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"joint-types",children:"Joint Types"}),"\n",(0,r.jsx)(n.p,{children:"URDF supports several joint types that define the degrees of freedom between connected links:"}),"\n",(0,r.jsx)(n.h3,{id:"fixed-joint",children:"Fixed Joint"}),"\n",(0,r.jsx)(n.p,{children:"A fixed joint constrains all motion between two links, effectively making them a single rigid body:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<joint name="fixed_joint" type="fixed">\n  <parent link="link1"/>\n  <child link="link2"/>\n</joint>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"revolute-joint",children:"Revolute Joint"}),"\n",(0,r.jsx)(n.p,{children:"A revolute joint allows rotation around a single axis with limited range:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<joint name="hinge_joint" type="revolute">\n  <parent link="upper_arm"/>\n  <child link="forearm"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n</joint>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"continuous-joint",children:"Continuous Joint"}),"\n",(0,r.jsx)(n.p,{children:"Similar to a revolute joint but with unlimited rotation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<joint name="continuous_joint" type="continuous">\n  <parent link="base"/>\n  <child link="rotating_part"/>\n  <axis xyz="0 0 1"/>\n</joint>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"prismatic-joint",children:"Prismatic Joint"}),"\n",(0,r.jsx)(n.p,{children:"Allows linear motion along a single axis:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<joint name="slider_joint" type="prismatic">\n  <parent link="base"/>\n  <child link="slider"/>\n  <axis xyz="1 0 0"/>\n  <limit lower="0" upper="0.5" effort="100" velocity="1"/>\n</joint>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"complete-urdf-example-simple-humanoid-robot",children:"Complete URDF Example: Simple Humanoid Robot"}),"\n",(0,r.jsx)(n.p,{children:"Here's a simplified URDF for a basic humanoid robot:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid">\n\n  \x3c!-- Base/Body Link --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass value="10.0"/>\n      <origin xyz="0 0 0"/>\n      <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\n    </inertial>\n    \n    <visual>\n      <origin xyz="0 0 0.5"/>\n      <geometry>\n        <box size="0.5 0.3 1.0"/>\n      </geometry>\n      <material name="body_color">\n        <color rgba="0.5 0.5 0.5 1.0"/>\n      </material>\n    </visual>\n    \n    <collision>\n      <origin xyz="0 0 0.5"/>\n      <geometry>\n        <box size="0.5 0.3 1.0"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Head Link --\x3e\n  <link name="head">\n    <inertial>\n      <mass value="2.0"/>\n      <origin xyz="0 0 0"/>\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>\n    </inertial>\n    \n    <visual>\n      <origin xyz="0 0 0"/>\n      <geometry>\n        <sphere radius="0.15"/>\n      </geometry>\n      <material name="head_color">\n        <color rgba="1.0 0.8 0.6 1.0"/>\n      </material>\n    </visual>\n    \n    <collision>\n      <origin xyz="0 0 0"/>\n      <geometry>\n        <sphere radius="0.15"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Joint connecting head to body --\x3e\n  <joint name="neck_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="head"/>\n    <origin xyz="0 0 1.0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.5" upper="0.5" effort="10" velocity="1"/>\n  </joint>\n\n  \x3c!-- Left Arm Example --\x3e\n  <link name="left_upper_arm">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0 0 -0.15"/>\n      <inertia ixx="0.05" ixy="0.0" ixz="0.0" iyy="0.05" iyz="0.0" izz="0.01"/>\n    </inertial>\n    \n    <visual>\n      <origin xyz="0 0 -0.15"/>\n      <geometry>\n        <cylinder length="0.3" radius="0.05"/>\n      </geometry>\n      <material name="arm_color">\n        <color rgba="0.5 0.5 0.5 1.0"/>\n      </material>\n    </visual>\n    \n    <collision>\n      <origin xyz="0 0 -0.15"/>\n      <geometry>\n        <cylinder length="0.3" radius="0.05"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Joint connecting left arm to body --\x3e\n  <joint name="left_shoulder_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="left_upper_arm"/>\n    <origin xyz="0.15 0.2 0.5"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="1.57" effort="10" velocity="1"/>\n  </joint>\n\n</robot>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"urdf-and-ros-2-integration",children:"URDF and ROS 2 Integration"}),"\n",(0,r.jsx)(n.h3,{id:"loading-urdf-in-ros-2",children:"Loading URDF in ROS 2"}),"\n",(0,r.jsxs)(n.p,{children:["In ROS 2, URDFs are typically loaded into the parameter server and accessed through the ",(0,r.jsx)(n.code,{children:"robot_state_publisher"})," node:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile\nfrom sensor_msgs.msg import JointState\nfrom tf2_ros import TransformBroadcaster\nimport math\n\nclass RobotStatePublisher(Node):\n    def __init__(self):\n        super().__init__('robot_state_publisher')\n        \n        # Create a QoS profile for the joint state subscriber\n        qos_profile = QoSProfile(depth=10)\n        \n        # Subscribe to joint states\n        self.joint_state_subscriber = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            qos_profile\n        )\n        \n        # Create transform broadcaster\n        self.tf_broadcaster = TransformBroadcaster(self)\n        \n    def joint_state_callback(self, msg):\n        # Process joint states and publish transforms\n        # This is simplified - a real implementation would be more complex\n        pass\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-xacro",children:"Using xacro"}),"\n",(0,r.jsx)(n.p,{children:"For complex robots, URDFs can become very large and repetitive. The XML Macro (xacro) package allows you to create more maintainable URDFs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_xacro">\n\n  \x3c!-- Define a property --\x3e\n  <xacro:property name="M_PI" value="3.1415926535897931" />\n\n  \x3c!-- Define a macro for repeated elements --\x3e\n  <xacro:macro name="simple_arm" params="side">\n    <link name="${side}_upper_arm">\n      <visual>\n        <geometry>\n          <cylinder length="0.3" radius="0.05"/>\n        </geometry>\n      </visual>\n    </link>\n    \n    <joint name="${side}_shoulder_joint" type="revolute">\n      <parent link="base_link"/>\n      <child link="${side}_upper_arm"/>\n      <axis xyz="0 1 0"/>\n      <limit lower="-1.57" upper="1.57" effort="10" velocity="1"/>\n    </joint>\n  </xacro:macro>\n\n  \x3c!-- Use the macro to create both arms --\x3e\n  <xacro:simple_arm side="left"/>\n  <xacro:simple_arm side="right"/>\n\n</robot>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"urdf-best-practices",children:"URDF Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"naming-conventions",children:"Naming Conventions"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use consistent naming schemes (e.g., snake_case)"}),"\n",(0,r.jsx)(n.li,{children:"Include descriptive names that indicate functionality"}),"\n",(0,r.jsx)(n.li,{children:"Use prefixes for related components (e.g., left_arm, right_arm)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"inertial-properties",children:"Inertial Properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Accurate inertial properties are crucial for physics simulation"}),"\n",(0,r.jsx)(n.li,{children:"Use CAD tools to calculate exact inertial properties"}),"\n",(0,r.jsx)(n.li,{children:"For real robots, determine properties through measurement or CAD models"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"visual-vs-collision-models",children:"Visual vs. Collision Models"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use detailed visual meshes for rendering"}),"\n",(0,r.jsx)(n.li,{children:"Use simpler collision geometries for performance"}),"\n",(0,r.jsx)(n.li,{children:"Align both visual and collision frames properly"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"humanoid-specific-considerations",children:"Humanoid-Specific Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"kinematic-chains",children:"Kinematic Chains"}),"\n",(0,r.jsx)(n.p,{children:"Humanoid robots have multiple kinematic chains (legs, arms) that must be properly connected to represent walking and manipulation capabilities."}),"\n",(0,r.jsx)(n.h3,{id:"degrees-of-freedom",children:"Degrees of Freedom"}),"\n",(0,r.jsx)(n.p,{children:"Humanoid robots typically have many degrees of freedom, requiring careful joint limit configuration to represent human-like ranges of motion."}),"\n",(0,r.jsx)(n.h3,{id:"balance-and-stability",children:"Balance and Stability"}),"\n",(0,r.jsx)(n.p,{children:"Proper center of mass calculation is crucial for humanoid robot simulation, especially for bipedal locomotion."}),"\n",(0,r.jsx)(n.h2,{id:"validation-and-debugging",children:"Validation and Debugging"}),"\n",(0,r.jsx)(n.h3,{id:"urdf-validation",children:"URDF Validation"}),"\n",(0,r.jsxs)(n.p,{children:["Use the ",(0,r.jsx)(n.code,{children:"check_urdf"})," tool to validate your URDF:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Assuming your URDF is in a package called my_robot_description\nros2 run robot_state_publisher robot_state_publisher --ros-args -p robot_description:=$(ros2 pkg prefix my_robot_description)/share/my_robot_description/urdf/my_robot.urdf\n"})}),"\n",(0,r.jsx)(n.h3,{id:"visualization",children:"Visualization"}),"\n",(0,r.jsx)(n.p,{children:"Use RViz2 to visualize your robot model and verify it matches your expectations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 run rviz2 rviz2\n"})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-urdf-features",children:"Advanced URDF Features"}),"\n",(0,r.jsx)(n.h3,{id:"gazebo-specific-elements",children:"Gazebo-Specific Elements"}),"\n",(0,r.jsx)(n.p,{children:"URDF can include Gazebo-specific elements for simulation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="link_name">\n  <material>Gazebo/Blue</material>\n  <mu1>0.9</mu1>\n  <mu2>0.9</mu2>\n</gazebo>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"transmission-elements",children:"Transmission Elements"}),"\n",(0,r.jsx)(n.p,{children:"Define how joints are controlled:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<transmission name="left_wheel_trans">\n  <type>transmission_interface/SimpleTransmission</type>\n  <joint name="left_wheel_joint">\n    <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>\n  </joint>\n  <actuator name="left_wheel_motor">\n    <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>\n    <mechanicalReduction>1</mechanicalReduction>\n  </actuator>\n</transmission>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"URDF is a fundamental component of the ROS ecosystem, allowing for the description of robot models that bridge the gap between digital representations and physical robot bodies. For humanoid robots, proper URDF modeling is essential for accurate simulation and effective control."}),"\n",(0,r.jsx)(n.p,{children:"Understanding the structure and components of URDFs, along with best practices for their creation, is crucial for creating embodied intelligence systems that can effectively interact with the physical world through humanoid robot platforms."}),"\n",(0,r.jsx)(n.p,{children:"In the next sections, we'll look at how to validate these models and use them in simulation and control systems."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453(e,n,i){i.d(n,{R:()=>l,x:()=>a});var r=i(6540);const o={},t=r.createContext(o);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);